{"name": "Einf\u00fchrung in den Theorembeweiser LEAN", "version": "2.0", "languages": ["en"], "translated_name": "0", "devmode": false, "library_zip_fn": "Einf\u00fchrung in den Theorembeweiser LEAN-2.0-library.zip", "introData": {"name": "1", "problemIndex": -1, "objects": [{"type": "text", "content": "2"}]}, "worlds": [{"name": "3", "levels": [{"name": "4", "problemIndex": 7, "objects": [{"type": "lean", "content": "5", "hidden": true}, {"type": "lean", "content": "6", "hidden": true}, {"type": "text", "content": "7"}, {"type": "hint", "content": "8", "title": "9"}, {"type": "text", "content": "10"}, {"type": "hint", "content": "11", "title": "12"}, {"type": "text", "content": "13"}, {"type": "theorem", "text": "14", "lean": "theorem succ_succ (a b : N) (h : succ(a) = b): succ(succ(a)) = succ(b) :=\n", "sideBar": true, "firstProofLineNumber": 84, "lastProofLineNumber": 87, "textBefore": "-- Level name : Die Peano Axiome\n\nimport mynat.definition -- hide\nnamespace N -- hide\n\n/-\nDie nat\u00fcrlichen Zahlen k\u00f6nnen mit Peanos Axiomen eindeutig definiert werden. Die\nAxiome lauten wie folgt:\n- $A_1$: $0$ (in LEAN entweder `0` oder `zero`) ist eine nat\u00fcrliche Zahl \n- $A_2$: Es gibt eine injektive Abbildung `succ`$: \\mathbb{N} \\to \\mathbb{N}$, die f\u00fcr jede nat\u00fcrliche Zahl ihren Nachfolger angibt.\n- $A_3$: $0$ ist nicht der Nachfolger einer nat\u00fcrlichen Zahl.\n- $A_4$: Das Prinzip der Induktion: Enth\u00e4lt eine Menge die $0$ und f\u00fcr jede enthaltene nat\u00fcrliche Zahl $n$ auch ihren Nachfolger `succ`$(n)$, so enth\u00e4lt sie alle nat\u00fcrlichen Zahlen.\n\nIn LEAN kann man die Anwendung der Abbildung `succ` auf `a` sowohl als `succ(a)` als auch \nals `a.succ` schreiben.\n-/\n\n/- Hint : Wieso brauchen wir hier die Abbildung `succ`, um den Nachfolger einer Zahl $n$ zu beschreiben, anstatt den Ausdruck n+1 zu verwenden?\nWir haben die Addition noch nicht definiert. Au\u00dferdem ist `succ`$(n)=n+1$ mit $1=$`succ`$(0)$ dann noch zu beweisen.\n-/\n\n/-\nAus diesen Axiomen werden wir alles herleiten und beweisen, was wir in dieser Einheit\nvorhaben. In diesem Level werden wir folgende Aussage zur Funktion `succ` zeigen: F\u00fcr die nat\u00fcrlichen Zahlen a und b gilt: falls `succ(a)=b` dann `succ(succ(a))=succ(b)`.\n\nDiese Aussage kann man direkt zeigen, indem man die gegebene Hypothese `succ(a)=b` in die\nzu zeigende Aussage `succ(succ(a))=succ(b)` einsetzt und somit `succ(b)=succ(b)` erh\u00e4lt.\n\nWir schauen uns nun an, wie das in LEAN funktioniert. Wir werden mit der Klasse\nN arbeiten, die genau die Menge der nat\u00fcrlichen Zahlen definiert nach den Peano-Axiomen \nist.\n-/\n\n/- Hint : Klicke hier, um die Definition der nat\u00fcrlichen Zahlen in LEAN zu sehen. Du musst diesen Code nicht zu 100% verstehen.\n`inductive N` \u2192 $A_4$ <br>\n`| zero : N` \u2192 $A_1$ <br>\n`| succ (n : N) : N` \u2192 $A_2$ <br>\n`lemma succ_inj {m n : N} (h : succ m = succ n) : m = n := by cases h; refl` \u2192 $A_2$ <br>\n`lemma zero_ne_succ (m : N) : (zero : N) \u2260 succ m := \u03bb h, by cases h` \u2192 $A_3$\n-/\n\n/-\nAls Erstes muss man das Lemma definieren, das man beweisen m\u00f6chte. Dies besteht aus drei \nTeilen.\n- Name: Der Name kann beliebig gew\u00e4hlt werden, ist im besten Fall aber eine gute \nBeschreibung des Lemmas. Hier kann man zum Beispiel \u201csucc_succ\u201d w\u00e4hlen, um anzudeuten, \ndass es um die Zweifachanwendung der Abbildung `succ` geht.\n- Voraussetzungen: Diese stehen zwischen dem Namen und dem Doppelpunkt. In diesem Fall\nsind das, dass a und b nat\u00fcrliche Zahlen sind und die Aussage h, dass `succ(a)=b`.\n- Folgerung: Diese steht zwischen dem Doppelpunkt und dem Definitionszeichen. In diesem\nFall also, `succ(succ(a))=b`.\n\nDer Beweis folgt zwischen dem `begin` und dem `end`. Zu Beginn der Bearbeitung steht im\nBeweis immer `sorry`. Dies ist ein Keyword, was so viel bedeutet wie: \"Hier fehlt ein\nTeil des Beweises\". Du kannst dieses Keyword verwenden, wenn ein Beweis \u00fcberpr\u00fcft werden\nsoll, bei dem dir noch ein Teil fehlt. LEAN wird best\u00e4tigen, dass der Beweis stimmt, aber\nmit dem warning \"uses `sorry`\" darauf hinweisen, dass noch etwas zu tun ist. L\u00f6sche als\nErstes das `sorry`, um mit dem Beweis zu starten.\n\nWir haben oben bereits beschrieben, wie der Beweis mathematisch funktioniert. Wie \n\u00fcbertragen wir die Idee in LEAN? Dazu gibt es den `rw` (rewrite) Befehl. Wenn `h` eine\nAussage ist (z.B. $a=b$), dann bewirkt `rw h,`, dass LEAN die Aussage `h` in der zu \nzeigenden Aussage einsetzt (im Beispiel w\u00fcrde also in der zu zeigenden Aussage jedes $a$\nmit einem $b$ ersetzt werden). Probiere also den Befehl `rw h,` aus. Das Komma am Ende \njedes LEAN-Befehls ist sehr wichtig. Wenn du Fehlermeldungen bekommst, die du nicht\nverstehst, \u00fcberpr\u00fcfe deinen Code auf fehlende Kommata.\n\nDie rechte Spalte:\nHier gibt LEAN dynamisches Feedback. Bis auf die letzte Zeile steht hier immer was \ngegeben ist, in diesem Fall zum Beispiel, dass a und b nat\u00fcrliche Zahlen sind und die\nAussage `h`. In der letzten Zeile, nach dem `\u22a2` Symbol, steht immer das aktuelle Ziel, \nalso das, was gerade zu  zeigen ist. Wenn man am Anfang des Beweises steht, ist das \nnoch die ganze Aussage des Lemmas. Nachdem man `rw h,` eingibt, sieht man, dass sich \nder Zustand \u00e4ndert. In diesem Fall kommt die Nachricht `Proof complete!`, die uns \nangibt, dass wir fertig sind. In l\u00e4ngeren Aufgaben w\u00fcrde hier das neue Ziel stehen. Ein\nBeweis ist dann zuende, wenn eine Aussage der Form \"a=a\" als Beweiszustand entsteht.\n-/\n\n/- Theorem\nSeien $a, b \\in \\mathbb{N}$. Falls `succ`$(a) = b$, dann `succ`$($`succ`$(a)) = $`succ`$(b)$.\n-/\ntheorem succ_succ (a b : N) (h : succ(a) = b): succ(succ(a)) = succ(b) :=\nbegin\n", "proof": "rw h,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : rw\n## Anleitung\nWenn `h` eine Aussage des Typs `X = Y` ist, dann wird\n`rw h,` alle `X` in der zu beweisenden Aussage durch\n`Y` austauschen.\nUm alle `Y` durch `X` zu ersetzten verwendet man `rw \u2190 h`.\n## Beispiel\nBei folgendem Zustand:\n```\nx : N\nh : x + 0 = 0\n\u22a2 succ (x + 0) = succ (x)\n```\nwird `rw h,` das Ziel um\u00e4ndern zu `\u22a2 succ (x) = succ (x)`,\nund damit den Beweis abschlie\u00dfen.\n## Erweitert\n1. Man kann einen konkreten Teil des Zustands konkretisieren,\num vorzugeben wo Lean `rw` anwenden soll. Bei dem Zustand:\n```\nx y : N\nh : x + 1 = y\n\u22a2 x + 0 + 1 = y + 0\n```\nwird `rw add_zero x,` den Zustand zu `x + 1 = y + 0` \u00e4ndern und\n`rw add_zero y,` zu `x + 0 + 1 = y`\n2. Man kann rw auch auf gegebene Hypothesen anwenden statt auf\nden Beweiszustand.Bei dem Zustand:\n```\nx : N\nh : x + 0 = 3\n\u22a2 x = 3 + 0\n```\nwird `rw add_zero at h,` den Beweiszustand nicht \u00e4ndern, daf\u00fcr aber\n`h` umformen zu `h : x = 3`\n-/\n\nend N -- hide", "height": 4, "editorText": "sorry", "lineOffset": 83, "name": "succ_succ", "statement": "(a b : N) (h : succ(a) = b): succ(succ(a)) = succ(b)"}, {"type": "tactic", "content": "15", "name": "rw", "sideBar": true}, {"type": "lean", "content": "16", "hidden": true}]}, {"name": "17", "problemIndex": 4, "objects": [{"type": "lean", "content": "18", "hidden": true}, {"type": "lean", "content": "19", "hidden": true}, {"type": "lean", "content": "20", "hidden": true}, {"type": "text", "content": "21"}, {"type": "theorem", "text": "22", "lean": "theorem succ_succ_zw (a b c : N) (h : succ(a) = b) (g : succ(b) = c): succ(succ(a)) = c :=\n", "sideBar": true, "firstProofLineNumber": 33, "lastProofLineNumber": 37, "textBefore": "-- Level name : Die Peano Axiome - Teil 2\n\nimport mynat.definition -- hide\nimport game.Peano.level_1 --hide\nnamespace N -- hide\n\n/-\nIn diesem Level passiert nicht viel. Es dient eher zur \u00dcbung von dem Gelernten in\nLevel 1 und um ein weiteres feature des `rw` Befehls zu verstehen.\n\nVielleicht hast du gemerkt, dass es eine linke Spalte gibt. Hier kannst du alle\nTools finden, die du zum Beweisen brauchst. Das sind einerseits die Befehle (wie\nz.B. `rw`), die in LEAN Tactics hei\u00dfen. Andererseits sind das die Axiome und Aussagen,\ndie wir bereits eingef\u00fchrt/bewiesen haben. Diese sind in der Kategorie Theorem\nstatements. Umso weiter du bist, umso mehr Inhalt wirst du hier finden.\n\nWir haben im vorherigem Level gesehen, dass f\u00fcr die Aussage `h: a = b` der Befehl\n`rw h,` in der zu zeigenden Aussage jedes `a` durch ein `b` ersetzt. Aber wie\nkann man jedes `b` durch ein `a` ersetzen? Dazu verwendet man den Befehl\n`rw \u2190 h,`. Der Pfeil steht sozusagen daf\u00fcr, dass LEAN die Aussage h von rechts\nnach links lesen soll. Du kannst den Pfeil mit \\ l (backslash + klein L)\nschreiben.\n\nDu kannst das untenstehende Lemma \u00e4hnlich wie Level 1 l\u00f6sen, aber erkennst du\nauch einen weiteren Weg der `\u2190` verwendet?\n-/\n\n/- Theorem\nSeien $a, b, c \\in \\mathbb{N}$. Falls `succ`$(a) = b$ und `succ`$(b)= c$, dann `succ`$($`succ`$(a)) = c$.\n-/\ntheorem succ_succ_zw (a b c : N) (h : succ(a) = b) (g : succ(b) = c): succ(succ(a)) = c :=\nbegin\n", "proof": "rw h,\nrw g,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide\n\n/- Hint : Brauchst du Hilfe, um einen zweiten Weg zu finden?\nIn der zu zeigenden Aussage kommt der Term `c` vor, der auch Teil der Aussage\n`g` ist. Du kannst also mit `rw \u2190 g,` das `c` in der Aussage ersetzen.\n-/", "height": 5, "editorText": "sorry", "lineOffset": 32, "name": "succ_succ_zw", "statement": "(a b c : N) (h : succ(a) = b) (g : succ(b) = c): succ(succ(a)) = c"}, {"type": "lean", "content": "23", "hidden": true}, {"type": "hint", "content": "24", "title": "25"}]}, {"name": "26", "problemIndex": 4, "objects": [{"type": "lean", "content": "27", "hidden": true}, {"type": "lean", "content": "28", "hidden": true}, {"type": "lean", "content": "29", "hidden": true}, {"type": "text", "content": "30"}, {"type": "theorem", "text": "31", "lean": "theorem succ_succ_zw2 (a b c : N) (h : succ(a) = b) (g : succ(succ(a)) = c): succ(b) = c :=\n", "sideBar": true, "firstProofLineNumber": 36, "lastProofLineNumber": 40, "textBefore": "-- Level name : Die Peano Axiome - Teil 3\n\nimport mynat.definition -- hide\nimport game.Peano.level_2 --hide\nnamespace N -- hide\n\n/-\nIn diesem Level werden wir wieder einen \u00e4hnlichen Satz wie im vorherigem Level\nl\u00f6sen. Wir m\u00f6chten aber dazu eine neue Eingeschaft der Tactic `rw` benutzen und\neine weitere Tactic kennenlernen.\n\nMan kann rw auch auf gegebene Hypothesen anwenden statt auf den Beweiszustand. Man\ngibt dazu mit `at hypothese` and, auf welche hypothese rw angewandt werden soll.\nBei folgendem Zustand, den wir aus dem vorherigem Level kennen:\n```\nx : N\nh : succ(a) = b\ng : succ(b) = c\n\u22a2 succ(succ(a)) = c\n```\nwird `rw \u2190 h at g,` den Beweiszustand nicht \u00e4ndern, daf\u00fcr aber `g` umformen zu \n`g : succ(succ(a))=c`. In diesem Beispiel h\u00e4tten wir dann eine Hypothese, die\nexakt gleich zu dem Beweiszustand ist. Um diese Hypothese zu verwenden um den\nBeweiszustand zu l\u00f6sen, k\u00f6nnen wir die `exact` tactic verwenden und den Beweis\nmit `exact g` schlie\u00dfen.\n\nDen Beweis in diesem Level kannst du ebenfalls mit `rw ... at ...,` und `exact...,`\nl\u00f6sen.\n-/\n\n/- Theorem\nSeien $a, b, c \\in \\mathbb{N}$. Falls `succ`$(a) = b$ und `succ`$($`succ`$(a)) = c$, dann `succ`$(b)= c$.\n-/\ntheorem succ_succ_zw2 (a b c : N) (h : succ(a) = b) (g : succ(succ(a)) = c): succ(b) = c :=\nbegin\n", "proof": "rw [h] at g,\nexact g,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : exact\n## Anleitung\nWenn `h` eine Aussage ist, die exakt gleich zu dem Beweiszustand\nist, dann l\u00f6st `exact h` den Beweis.\n## Beispiel\nBei folgendem Zustand:\n```\nx y : N\nh : x + 1 = y\n\u22a2 x + 1 = y\n```\nl\u00f6st `exact h` den Beweis.\n-/\n\nend N -- hide\n\n/- Hint : Brauchst du Hilfe, um einen zweiten Weg zu finden?\nIn der zu zeigenden Aussage kommt der Term `c` vor, der auch Teil der Aussage\n`g` ist. Du kannst also mit `rw \u2190 g,` das `c` in der Aussage ersetzen.\n-/", "height": 5, "editorText": "sorry", "lineOffset": 35, "name": "succ_succ_zw2", "statement": "(a b c : N) (h : succ(a) = b) (g : succ(succ(a)) = c): succ(b) = c"}, {"type": "tactic", "content": "32", "name": "exact", "sideBar": true}, {"type": "lean", "content": "33", "hidden": true}, {"type": "hint", "content": "34", "title": "35"}]}]}, {"name": "36", "levels": [{"name": "37", "problemIndex": 9, "objects": [{"type": "lean", "content": "38", "hidden": true}, {"type": "lean", "content": "39", "hidden": true}, {"type": "lean", "content": "40", "hidden": true}, {"type": "lean", "content": "41", "hidden": true}, {"type": "axiom", "content": "42", "name": "add_zero (a : N) :", "sideBar": true}, {"type": "axiom", "content": "43", "name": "add_succ (a b : N) :", "sideBar": true}, {"type": "text", "content": "44"}, {"type": "hint", "content": "45", "title": "46"}, {"type": "text", "content": "47"}, {"type": "theorem", "text": "48", "lean": "theorem succ_add_zero (a : N) : succ(a)+0=succ(a+0) :=\n", "sideBar": true, "firstProofLineNumber": 62, "lastProofLineNumber": 63, "textBefore": "-- Level name : Die Addition\n\n-- namespace nat -- hide \nimport mynat.add -- hide\nimport game.Peano.level_3 -- hide\nnamespace N -- hide\n\n/- Axiom : add_zero (a : N) :\na + 0 = a\n-/\n\n/- Axiom : add_succ (a b : N) :\na + succ(b) = succ(a + b)\n-/\n\n\n/-\nMan kann die Addition zweier nat\u00fcrlichen Zahlen rekursiv anhand der Peano-Axiome \ndefinieren.\n- F\u00fcr $a \\in \\mathbb{N}$ sei $a+0=a$\n- F\u00fcr $a,d \\in \\mathbb{N}$ sei $a+$`succ`$(d) = $`succ`$(a+d)$\n\nNach dem Prinzip der Induktion ist dann die Addition f\u00fcr alle Paare von nat\u00fcrlichen\nZahlen definiert.\n\nDie beiden Aussagen, die die Addition definieren, sind in LEAN implementiert und \nhaben jeweils den Namen `add_zero` und `add_succ`. Auch diese Aussagen k\u00f6nnen mit\ndem Befehl `rw` verwendet werden. `rw add_zero,` wandelt die Aussage `b+zero` in `b`\num.\n-/\n\n/- Hint : Klicke hier, um die Definition der Addition der nat\u00fcrlichen Zahlen in LEAN zu sehen. Du musst diesen Code nicht zu 100% verstehen.\nDefinition: <br>\n`def add : N \u2192 N \u2192 N` <br>\n`| m 0 := m` <br>\n`| m (succ n) := succ (add m n)` <br>\n\nDen beiden definierenden Eigenschaften wird ein Namen gegeben: <br>\n`lemma add_zero (m : N) : m + zero = m := rfl` <br>\n`lemma add_succ (m n : N) : m + succ n = succ (m + n) := rfl`\n-/\n\n/-\nIn diesem Level werden wir eine Aussage beweisen, in der die Addition der\nnat\u00fcrlichen Zahlen vorkommt. Die Aussage ist: Sei $a \\in \\mathbb{N}$. \nDann ist `succ`$(a)+0=$`succ`$(a+0)$. Wir k\u00f6nnen diese Aussage beweisen,\nindem wir die Aussage `add_zero` mit `rw` auf den Beweiszustand anwenden.\n\nIn dieser Aussage kommen zwei Ausr\u00fccke der Form $n+0$ vor. Man kann bei der\nTactic rw konkretisieren, auf welche der beiden Stellen rw angewandt werden\nsoll. Probiere in dem Beweis erst `rw add_zero a,` aus. L\u00f6sche diese Zeile\nund schreibe stattdessen `rw add_zero a.succ,`. Siehts du den unterschied im\nBeweiszustand?\n-/\n\n/- Theorem\nSei $a \\in \\mathbb{N}$. Dann ist `succ`$(a)+0=$`succ`$(a+0)$.\n-/\n\ntheorem succ_add_zero (a : N) : succ(a)+0=succ(a+0) :=\nbegin\n", "proof": "rw add_zero a,\nrw add_zero a.succ,", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide", "height": 2, "editorText": "sorry", "lineOffset": 61, "name": "succ_add_zero", "statement": "(a : N) : succ(a)+0=succ(a+0)"}, {"type": "lean", "content": "49", "hidden": true}]}, {"name": "50", "problemIndex": 4, "objects": [{"type": "lean", "content": "51", "hidden": true}, {"type": "lean", "content": "52", "hidden": true}, {"type": "lean", "content": "53", "hidden": true}, {"type": "text", "content": "54"}, {"type": "theorem", "text": "55", "lean": "theorem add_succ_zero (a : N) : a + succ(0) = succ(a) :=\n", "sideBar": true, "firstProofLineNumber": 18, "lastProofLineNumber": 22, "textBefore": "-- Level name : Addition mit dem Nachfolger von 0\n\nimport mynat.add -- hide\nimport game.Addition.level_1 --hide\nnamespace N -- hide\n\n/-\nIn diesem Level werden wir zeigen, dass Addition mit dem Nachfolger von $0$ (den\nwir noch nicht formal als $1$ eingef\u00fchrt haben), gleich dem Nachfolger der Zahl ist.\nL\u00f6se den Beweis mit `rw` und den verf\u00fcgbaren Axiomen.\n-/\n\n/- Theorem\nSei $a \\in \\mathbb{N}$. Dann ist $a+$`succ`$(0)=$`succ`$(a)$\n-/\ntheorem add_succ_zero (a : N) : a + succ(0) = succ(a) :=\nbegin\n", "proof": "  rw add_succ,\n  rw add_zero,\n\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide", "height": 5, "editorText": "sorry", "lineOffset": 17, "name": "add_succ_zero", "statement": "(a : N) : a + succ(0) = succ(a)"}, {"type": "lean", "content": "56", "hidden": true}]}, {"name": "57", "problemIndex": 7, "objects": [{"type": "lean", "content": "58", "hidden": true}, {"type": "lean", "content": "59", "hidden": true}, {"type": "lean", "content": "60", "hidden": true}, {"type": "axiom", "content": "61", "name": "one_eq_succ_zero (a : N) :", "sideBar": true}, {"type": "text", "content": "62"}, {"type": "hint", "content": "63", "title": "64"}, {"type": "text", "content": "65"}, {"type": "theorem", "text": "66", "lean": "theorem succ_eq_add_one (a : N) : succ(a) = a + 1 :=\n", "sideBar": true, "firstProofLineNumber": 33, "lastProofLineNumber": 38, "textBefore": "-- Level name : Die nat\u00fcrliche Zahl 1\n\nimport mynat.add -- hide\nimport game.Addition.level_2 --hide\nnamespace N -- hide\n\n/- Axiom : one_eq_succ_zero (a : N) :\none = succ(zero)\n-/\n\n/-\nAus praktischen Gr\u00fcnden m\u00f6chten wir nun dem Nachfolger von $0$ einen Namen\ngeben. Diese Zahl nennen wir $1$. Die Aussage `one = succ(zero)` hei\u00dft in\nLEAN `one_eq_succ_zero`.\n-/\n\n/- Hint : Klicke hier, um die Definition der Nummer $1$ in LEAN zu sehen. Du musst diesen Code nicht zu 100% verstehen.\n`def one : N := succ zero` <br>\n`theorem one_eq_succ_zero : one = succ zero := rfl`\n-/\n\n/- \nNun k\u00f6nnen wir zeigen, dass der Nachfolger von $a$ gleich $a+1$ ist. L\u00f6se\nden Beweis mit `rw` und den verf\u00fcgbaren Axiomen `one_eq_succ_zero`,\n`add_succ` und `add_zero`. \n-/\n\n/- Theorem\nSei $a \\in \\mathbb{N}$. Dann ist `succ`$(a) = a + 1$.\n-/\ntheorem succ_eq_add_one (a : N) : succ(a) = a + 1 :=\nbegin\n", "proof": "rw one_eq_succ_zero,\nrw add_succ,\nrw add_zero,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide", "height": 6, "editorText": "sorry", "lineOffset": 32, "name": "succ_eq_add_one", "statement": "(a : N) : succ(a) = a + 1"}, {"type": "lean", "content": "67", "hidden": true}]}, {"name": "68", "problemIndex": 5, "objects": [{"type": "lean", "content": "69", "hidden": true}, {"type": "lean", "content": "70", "hidden": true}, {"type": "lean", "content": "71", "hidden": true}, {"type": "tactic", "content": "72", "name": "induction", "sideBar": true}, {"type": "text", "content": "73"}, {"type": "theorem", "text": "74", "lean": "theorem zero_add (a : N) : 0 + a = a :=\n", "sideBar": true, "firstProofLineNumber": 69, "lastProofLineNumber": 76, "textBefore": "-- Level name : Addition mit 0 - von links\n\nimport mynat.add -- hide\nimport game.Addition.level_3 --hide\nnamespace N -- hide\n\n/- Tactic : induction\n## Anleitung\nfalls `n : N` gegeben ist, dann startet `induction n with d hd`\neinen Induktionsbeweis \u00fcber `n` der zu beweisenden Aussage. `d` wird \nder Name der Variable im Induktionsschritt sein, und `hd` ist die Aussage\nder Induktionsvoraussetzung.\n## Beispiel\nBei folgendem Zustand:\n```\nn : N\n\u22a2 2 * n = n + n\n```\nwird `induction n with d hd` zwei neue Ziele \u00f6ffnen:\n```\n\u22a2 2 * 0 = 0 + 0\n```\nund\n```\nd : N,\nhd : 2 * d = d + d\n\u22a2 2 * succ d = succ d + succ d\n```\n## Bemerkung\nF\u00fcr LEAN soll der Induktionsanfang f\u00fcr `zero` gezeigt werden. Wir arbeiten\naber mit der Darstellung `0` der Zahl Null. Deswegen m\u00fcssen wir im Induktionsanfang\ndie Darstellung der Null mit `rw N_zero_eq_zero,` von `zero` zu `0` \u00e4ndern.\n-/\n\n/-\nNach Definition der Addition gilt: $a+0=a$. Wir haben aber noch nicht bewiesen,\ndass die Addition kommutativ ist. Es ist also noch nicht bewiesen, dass auch\n$0+a=a$ gilt.\n\nDies werden wir \u00fcber Induktion zeigen. Dazu lernen wir die `induction` Tactic in\nLEAN. Um einen Induktionsbeweis zu starten, m\u00fcssen wir `induction a with d hd,`\nschreiben. Dabei ist das $a$ die Variable, \u00fcber die induziert werden soll, $d$\nwird der Name der Variable im Induktionsschritt sein, und `hd` ist die Aussage\nder Induktionsvoraussetzung.\n\nNachdem du den Befehl `induction a with d hd,` eingibst, wirst du in der rechten\nSpalte sehen, dass du zwei Beweisziele hast: den Induktionsanfang und die \nInduktionsvoraussetzung. Um den Beweis \u00fcbersichtlicher zu f\u00fchren, kannst du\ndie zwei Teile mit geschweiften Klammern umgeben. Dein Beweis hat dann die Form: <br>\n`begin` <br>\n  `induction a with d hd,` <br>\n  `{},` <br>\n  `{},` <br>\n`end` <br>\nInnerhalb der geschweiften Klammern kannst du dann jeweils den Induktionsanfang und\nden Induktionsschritt zeigen. Hinter die Klammern, wie auch hinter jedem Schritt in\nden Klammern geh\u00f6rt wie immer ein \",\".\n\nACHTUNG: F\u00fcr LEAN soll der Induktionsanfang f\u00fcr `zero` gezeigt werden. Wir arbeiten\naber mit der Darstellung `0` der Zahl Null. Deswegen m\u00fcssen wir im Induktionsanfang\ndie Darstellung der Null mit `rw N_zero_eq_zero,` von `zero` zu `0` \u00e4ndern.\n-/\n\n/- Theorem\nSei $a \\in \\mathbb{N}$. Dann ist $0+a=a$.\n-/\ntheorem zero_add (a : N) : 0 + a = a :=\nbegin\n", "proof": "  induction a with d hd,\n  {rw N_zero_eq_zero,\n   rw add_zero,},\n  {rw add_succ,\n  rw hd,},\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide", "height": 8, "editorText": "sorry", "lineOffset": 68, "name": "zero_add", "statement": "(a : N) : 0 + a = a"}, {"type": "lean", "content": "75", "hidden": true}]}, {"name": "76", "problemIndex": 5, "objects": [{"type": "lean", "content": "77", "hidden": true}, {"type": "lean", "content": "78", "hidden": true}, {"type": "lean", "content": "79", "hidden": true}, {"type": "text", "content": "80"}, {"type": "text", "content": "81"}, {"type": "theorem", "text": "82", "lean": "theorem add_assoc (a b c : N) : (a + b) + c = a + (b + c) :=\n", "sideBar": true, "firstProofLineNumber": 50, "lastProofLineNumber": 57, "textBefore": "-- Level name : Assoziativit\u00e4t der Addition\n\nimport mynat.add -- hide\nimport game.Addition.level_4 --hide\nnamespace N -- hide\n\n/-\nNun werden wir die Assoziativit\u00e4t der Addition der nat\u00fcrlichen\nZahlen zeigen. Das bedeutet $(a + b) + c = a + (b + c)$. Dies ist wieder\n\u00fcber einen Induktionsbeweis m\u00f6glich. In diesem Level werden wir uns \neinen fertigen Beweis anschauen und dann mit der neuen Tactic \"repeat\" verk\u00fcrzen.\n\nAls erstes kannst du dazu folgenden Beweis als L\u00f6sung reikopieren und ihn\nSchritt f\u00fcr Schritt nachvollziehen.\n```\ninduction c with d hd,\n  {rw N_zero_eq_zero,\n  rw add_zero,\n  rw add_zero,},\n  {rw add_succ (a+b) d,\n  rw add_succ,\n  rw add_succ,\n  rw hd,},\n```\nWie du siehst muss man in diesem Beweis sowohl im Induktionsanfang wie im\nInduktionschritt den gleichen Beweisschritt mehrmals hintereinander ausf\u00fchren.\nDas kann man in LEAN mit der Tactic \"repeat\" verk\u00fcrzen, die einen gegebenen\nBeweisschritt so oft wiederholt, wie es m\u00f6glich ist. Bei dem Zustand:\n```\na : N, \n\u22a2 a + 0 + 0 + 0 = a\n```\nwird der Befehl `repeat{rw add_zero,},` dreimal den Befehl `add_zero` anwenden\nund somit den Beweiszustand zu `a=a` umformen und den Beweis schlie\u00dfen. Achte\nauf das Komma innehalb wie auch au\u00dferhalb der Klammer.\n\nVerwende nun `repeat` um den vorhandenen Beweis zu verk\u00fcrzen.\n-/\n\n/-\nNoch eine Bemerkung: LEAN ist linksassoziativ. Das bedeutet, dass f\u00fcr LEAN\n$a+b+b$ das gleiche wie $(a+b)+c$ ist.\n-/\n\n/- Theorem\nSeien $a, b, c \\in \\mathbb{N}$. Dann ist $(a + b) + c = a + (b + c)$.\n-/\ntheorem add_assoc (a b c : N) : (a + b) + c = a + (b + c) :=\nbegin\n", "proof": "  induction c with d hd,\n  {rw N_zero_eq_zero,\n  repeat{rw add_zero,},},\n  {repeat{rw add_succ,},\n  rw hd,},\n\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : repeat\n## Anleitung\nf\u00fcr einen Beweisschritt `step,`, f\u00fchrt `repeat {step,},` so oft den\nBeweisschritt aus wie es m\u00f6glich ist.\n## Beispiel\nBei folgendem Zustand:\n```\na : N, \n\u22a2 a + 0 + 0 + 0 = a\n```\nwird `repeat{rw add_zero,},` dreimal den Befehl `add_zero` anwenden\nund somit den Beweiszustand zu `a=a` umformen und den Beweis schlie\u00dfen.\n-/\n\nend N -- hide", "height": 8, "editorText": "sorry", "lineOffset": 49, "name": "add_assoc", "statement": "(a b c : N) : (a + b) + c = a + (b + c)"}, {"type": "tactic", "content": "83", "name": "repeat", "sideBar": true}, {"type": "lean", "content": "84", "hidden": true}]}, {"name": "85", "problemIndex": 4, "objects": [{"type": "lean", "content": "86", "hidden": true}, {"type": "lean", "content": "87", "hidden": true}, {"type": "lean", "content": "88", "hidden": true}, {"type": "text", "content": "89"}, {"type": "theorem", "text": "90", "lean": "theorem succ_add (a b: N) : succ(a) + b = succ(a + b) :=\n", "sideBar": true, "firstProofLineNumber": 35, "lastProofLineNumber": 44, "textBefore": "-- Level name : Addition mit dem Nachfolger - von links\n\nimport mynat.add -- hide\nimport game.Addition.level_5 --hide\nnamespace N -- hide\n\n/-\nGenauso wie wir aus $a+0=a$ nicht direkt $0+a=a$ folgern k\u00f6nnten, k\u00f6nnen wir\naus $b + $`succ`$(a) =$ `succ`$(b+a)$ nicht `succ`$(a)+b =$ `succ`$(a+b)$\nfolgern. Wir haben n\u00e4mlich noch nicht bewiesen, dass die Addition kommutativ ist.\n\nAuch hier k\u00f6nnen wir einen Induktionsbeweis f\u00fchren. In diesem Level wirst du einen\nunvollst\u00e4ndigen Beweis vervollst\u00e4ndigen.\n\nKopiere dazu folgenden unvollst\u00e4ndigen Beweis in die Aufgabe:\n```\ninduction b with d hd,\n  {rw N_zero_eq_zero,\n  rw add_zero,\n  rw add_zero,},\n  {sorry,},\n```\nKlicke dich durch den Beweis und achte dabei auf den Beweiszustand und wie er sich\nmit den unterschiedlichen Beweisschritten \u00e4ndert. Zu erg\u00e4nzen ist der Induktionsschritt,\nder zurzeit noch durch `sorry,` platzhaltend \"gel\u00f6st\" ist. \n\nL\u00f6sche dieses `sorry,` und erg\u00e4nze den Induktionsschritt.\n-/\n\n/- Theorem\nSeien $a, b \\in \\mathbb{N}$. Dann ist `succ`$(a)+b = $`succ`$(a+b)$.\n-/\ntheorem succ_add (a b: N) : succ(a) + b = succ(a + b) :=\nbegin\n", "proof": "  induction b with d hd,\n  {rw N_zero_eq_zero,\n  rw add_zero,\n  rw add_zero,},\n  {rw add_succ,\n  rw hd,\n  rw add_succ,},\n\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Hint : Kommst du mit dem Induktionsschritt nicht weiter?\nDer Induktionschritt kann wiefolgt gef\u00fchrt werden:\n```\nrw add_succ,\nrw hd,\nrw add_succ,\n```\nKopiere diesen Code und versuche ihn Schritt f\u00fcr Schritt nachzuvollziehen.\n-/\n\nend N -- hide", "height": 10, "editorText": "sorry", "lineOffset": 34, "name": "succ_add", "statement": "(a b: N) : succ(a) + b = succ(a + b)"}, {"type": "hint", "content": "91", "title": "92"}, {"type": "lean", "content": "93", "hidden": true}]}, {"name": "94", "problemIndex": 4, "objects": [{"type": "lean", "content": "95", "hidden": true}, {"type": "lean", "content": "96", "hidden": true}, {"type": "lean", "content": "97", "hidden": true}, {"type": "text", "content": "98"}, {"type": "theorem", "text": "99", "lean": "theorem add_comm (a b: N) : a + b = b + a :=\n", "sideBar": true, "firstProofLineNumber": 35, "lastProofLineNumber": 44, "textBefore": "-- Level name : Kommutativit\u00e4t der Addition\n\nimport mynat.add -- hide\nimport game.Addition.level_6 --hide\nnamespace N -- hide\n\n/-\nEndlich k\u00f6nnen wir zeigen, dass die Addition kommutativ ist!\n\nAuch hier k\u00f6nnen wir einen Induktionsbeweis f\u00fchren. In diesem Level wirst du einen\nfast richtigen Beweis korrigieren.\n\nKopiere dazu folgenden Beweis mit Fehler in die Aufgabe:\n```\ninduction b with d hd,\n{rw N_zero_eq_zero,\nrw add_zero a,\nrw zero_add a,},\n{rw add_succ a,\nrw hd,\nrw succ_add b,},\n```\nKlicke dich durch den Beweis und achte dabei auf den Beweiszustand und wie er sich\nmit den unterschiedlichen Beweisschritten \u00e4ndert. Zu korrigieren ist der Induktionsschritt. \n\nFinde den Fehler, indem du insbesondere auf die Fehlermeldung achtest. Kannst du den Beweis\nkorrigieren?\n-/\n\n/- Theorem\nSeien $a, b \\in \\mathbb{N}$. Dann ist a+b=b+a.\n-/\ntheorem add_comm (a b: N) : a + b = b + a :=\nbegin\n", "proof": "  induction b with d hd,\n  {rw N_zero_eq_zero,\n  rw add_zero a,\n  rw zero_add a,},\n  {rw add_succ a,\n  rw hd,\n  rw succ_add d,},\n\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Hint : Kommst du mit der Fehlersuche nicht weiter?\nDer Fehler `unknown identifier 'b'` deutet darauf hin, dass LEAN die Variable `b` in diesem\nKontext nicht kennt. Denk daran, dass im Induktionschritt bewiesen wird, dass falls die\nAussage f\u00fcr ein `d` (also a+d=d+a) gilt, die Aussage auch f\u00fcr `d.succ` \n(also a+d.succ = d.succ+a) gilt. Hier kommt also kein `b` mehr vor.\n-/\n\nend N -- hide", "height": 10, "editorText": "sorry", "lineOffset": 34, "name": "add_comm", "statement": "(a b: N) : a + b = b + a"}, {"type": "hint", "content": "100", "title": "101"}, {"type": "lean", "content": "102", "hidden": true}]}, {"name": "103", "problemIndex": 4, "objects": [{"type": "lean", "content": "104", "hidden": true}, {"type": "lean", "content": "105", "hidden": true}, {"type": "lean", "content": "106", "hidden": true}, {"type": "text", "content": "107"}, {"type": "theorem", "text": "108", "lean": "theorem add_right_comm (a b c: N) : a + b + c = a + c + b :=\n", "sideBar": true, "firstProofLineNumber": 34, "lastProofLineNumber": 39, "textBefore": "-- Level name : Kommutativit\u00e4t der rechten Summanden\n\nimport mynat.add -- hide\nimport game.Addition.level_7 --hide\nnamespace N -- hide\n\n/-\nDas Ziel dieses Levels ist f\u00fcr nat\u00fcrliche Zahlen $a,b,c$ $a+b+c=a+c+b$ zu zeigen.\nDas sieht vielleicht erstmal danach aus, dass du nur `add_comm,` anwenden muss. \nAber LEAN ist links-assoziativ. Das bedeutet, dass diese Aussage mit Klammern so \ngeschrieben werden kann: $(a+b)+c=(a+c)+b$. Um dieses Lemma zu zeigen, wirst du also \nauch die Assoziativit\u00e4t verwenden. Dieses Lemma wird dir in zuk\u00fcnftigen Beweisen etwas \nSchreibarbeit sparen.\n\nIn diesem Level werden dir die Beweischritte \"in normaler Sprache\" vorgegeben, die du\ndann in LEAN-Spache umsetzten kannst. Der Beweis besteht aus drei Schritten. Wir empfehlen\nbei jedem Schritt zu spezifizieren, auf welchen Teil sich rw beziehen soll.\n\n1. Wende die Assoziativit\u00e4t der Addition an, um in der linken Seite des Ausdrucks \numzuklammern.  Der Beweiszustand a + b + c = a + c + b soll zu a + (b + c) = a + c + b werden.\n2. Wende die Kommutativit\u00e4t der Addition an, um das b und c in der linken Seite des\nAusdrucks umzuklammern. Der Beweiszustand a + (b + c) = a + c + b soll zu \na + (c + b) = a + c + b werden.\n3. Wende die Assozitivit\u00e4t der Addition nun r\u00fcckwerts an, um in der linken Seite des\nAusdrucks umzuklammern. Der Beweiszustand a + (c + b) = a + c + b soll zu \na + c + b = a + c + b werden und somit den Beweis l\u00f6sen.\n-/\n\n/- Theorem\nSeien $a, b, c \\in \\mathbb{N}$. Dann ist $a+b+c=a+c+b$.\n-/\ntheorem add_right_comm (a b c: N) : a + b + c = a + c + b :=\nbegin\n", "proof": "rw add_assoc a b c,\nrw add_comm b c,\nrw \u2190 add_assoc a c b,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide", "height": 6, "editorText": "sorry", "lineOffset": 33, "name": "add_right_comm", "statement": "(a b c: N) : a + b + c = a + c + b"}, {"type": "lean", "content": "109", "hidden": true}]}, {"name": "110", "problemIndex": 5, "objects": [{"type": "lean", "content": "111", "hidden": true}, {"type": "lean", "content": "112", "hidden": true}, {"type": "lean", "content": "113", "hidden": true}, {"type": "text", "content": "114"}, {"type": "lean", "content": "115", "hidden": false}, {"type": "theorem", "text": "116", "lean": "theorem ex_add_10 : (\u2203 a b : \u2115, a+b=10) :=\n", "sideBar": true, "firstProofLineNumber": 42, "lastProofLineNumber": 42, "textBefore": "-- Level name : Ein Existenzbeweis\n\nimport data.nat.basic -- hide\nimport tactic -- hide\nnamespace nat -- hide\n\n/-\nNun hast du alle grundlegenden Eigenschaften der Addition gezeigt. In den\nverbleibenden Levels der \"Addition\" m\u00f6chten wir nun ein bisschen \"rechnen\".\n\nIn diesem Level geht es konkret darum zu zeigen, dass es nat\u00fcrliche Zahlen\n$a$ und $b$ gibt, sodass a+b=10. Um das zu Beweisen muss man nur ein solches\nPaar an Zahlen angeben, zum Beispiel $4$ und $6$. In diesem Level werden wir\ndie Tactic `use` kennenlernen, mit der man bei Existenzaussagen im Beweiszustand\nkonkrete Objekte \u00fcbergeben kann. Wir f\u00fchren `use` am Beispiel dieses Levels ein:\nDer Zustand ist:\n```\n\u22a2 \u2203 (a b : \u2115), a + b = 10\n```\nMit `use [4,6],` wird der Beweiszustand ersetzt durch `\u22a2 4 + 6 = 10`, was den\nBeweis direkt l\u00f6st. \nProbier diesen Schritt direkt im Beweis aus. Du kannst $4$ und $6$ nun auch durch\nandere Zahlenpaare ersetzen, die $10$ ergeben. Probiere zuletzt noch aus, den\nSchritt einzuteilen in:\n```\nuse [4],\nuse [6],\n```\ndann kannst du im Zwischenschritt nachvollziehen, was `use` ver\u00e4ndert hat.\n-/\n\n/- F\u00fcr welches $a \\in \\mathbb{N}$ kann der Beweis mit `repeat{use a,},` gel\u00f6st werden?\nDas funktioniert nur mit $a=5$. In diesem Fall wird dann zweimal `use 5,` ausgef\u00fchrt,\nwas analog zu `use [5,5],` ist. Probier es doch mal aus!\n-/\n\n/- Theorem\nEs existieren $a, b, \\in \\mathbb{N}$, sodass a+b=10.\n-/\ntheorem ex_add_10 : (\u2203 a b : \u2115, a+b=10) :=\nbegin\n", "proof": "use [4,6],", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : use\n## Anleitung\nf\u00fcr einen Beweiszustand `\u22a2 \u2203 (a : \u2115), Aussage(a)` setzt `use [b],` `b` ein,\nsodass der Beweiszustand zu `\u22a2 Aussage(b)` wird. `b` muss nicht eine konkrete\nZahl sein, sonder kann eine Variable sein, zum Beispiel eine Induktionsvariable.\nEs k\u00f6nnen mehrer Werte \u00fcbergeben werden (`[b,c]`), wenn die Existenzaussage mehrere\nVariablen enth\u00e4lt. \n## Beispiel\nBei folgendem Zustand:\n```\n\u22a2 \u2203 (a b : \u2115), a + b = 10\n```\nsetzt `use [4,6],` jeweils $4$ und $6$ f\u00fcr `a` und `b` ein und l\u00f6st den Beweis.\n-/\n\nend nat -- hide", "height": 1, "editorText": "sorry", "lineOffset": 41, "name": "ex_add_10", "statement": "(\u2203 a b : \u2115, a+b=10)"}, {"type": "tactic", "content": "117", "name": "use", "sideBar": true}, {"type": "lean", "content": "118", "hidden": true}]}, {"name": "119", "problemIndex": 6, "objects": [{"type": "lean", "content": "120", "hidden": true}, {"type": "lean", "content": "121", "hidden": true}, {"type": "lean", "content": "122", "hidden": true}, {"type": "lean", "content": "123", "hidden": true}, {"type": "text", "content": "124"}, {"type": "hint", "content": "125", "title": "126"}, {"type": "theorem", "text": "127", "lean": "theorem lineare_gleichung (a : \u2115) (h : a+3=8) : a=5 :=\n", "sideBar": true, "firstProofLineNumber": 41, "lastProofLineNumber": 41, "textBefore": "-- Level name : L\u00f6sung einer Linearen Gleichung\n\n-- namespace nat -- hide \n\nimport data.nat.basic -- hide\nimport tactic -- hide\nnamespace nat -- hide\n\n/-\nIn diesem Level wirst du Beweisen, dass $a=5$ die lineare Gleichung\n$a+3=8$ l\u00f6st. Dazu braucht man die Rechenregeln der Addition, die du\nja bereits bewiesen hast. Wir wollen diese aber nicht mehr Schritt \nf\u00fcr Schritt anwenden, sondern lineare Umformungen direkt LEAN \u00fcberlassen.\n\nDazu gibt es die Tactic `linarith`, die automatisch den Beweiszustand mithilfe\nder gegebenen Hypothesen und linearen arithmetischen Operationen vereinfacht.\nDu kannst diesen Beweis l\u00f6sen, indem du einfach `linarith,` schreibst.\n-/\n\n/- Hint : Ohne `linarith` w\u00e4re der Beweis aufw\u00e4ndig.\nWir w\u00fcrden folgende Umformungen an `h` machen:\na+3=8\na+succ(2)=8\nsucc(a+2)=8\nsucc(a+succ(1))=8\nsucc(succ(a+1))=8\nsucc(succ(a+succ(0)))=8\nsucc(succ(succ(a+0)))=8\nsucc(succ(succ(a)))=8\nsucc(succ(succ(a)))=succ(7)\nsucc(succ(succ(a)))=succ(succ(6))\nsucc(succ(succ(a)))=succ(succ(succ(5)))\na = 5\n-/\n\n/- Theorem\nSei $a \\in \\mathbb{N}$ mit $a+3=5$. Dann ist a=5.\n-/\ntheorem lineare_gleichung (a : \u2115) (h : a+3=8) : a=5 :=\nbegin\n", "proof": "linarith,", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : linarith\n## Anleitung\nDie Taktik `linarith` in Lean f\u00fchrt lineare Arithmetik,\num automatisch Ungleichungen und Gleichungen in nat\u00fcrlichen Zahlen zu l\u00f6sen\n## Beispiel\nBei folgendem Zustand:\n```\na: \u2115\nh: a + 3 = 8\n\u22a2 a = 5\n```\nl\u00f6st `linarith,` durch arithmetische Umformunge den Beweis.\n-/\nend nat -- hide", "height": 1, "editorText": "sorry", "lineOffset": 40, "name": "lineare_gleichung", "statement": "(a : \u2115) (h : a+3=8) : a=5"}, {"type": "tactic", "content": "128", "name": "linarith", "sideBar": true}, {"type": "lean", "content": "129", "hidden": true}]}, {"name": "130", "problemIndex": 4, "objects": [{"type": "lean", "content": "131", "hidden": true}, {"type": "lean", "content": "132", "hidden": true}, {"type": "lean", "content": "133", "hidden": true}, {"type": "text", "content": "134"}, {"type": "theorem", "text": "135", "lean": "theorem lin_gl_zwischenschritt (a : \u2115) (h : a + 2 = 4): a + 3=5 :=\n", "sideBar": true, "firstProofLineNumber": 38, "lastProofLineNumber": 42, "textBefore": "-- Level name : L\u00f6sung einer linearen Gleichung mit Zwischenschritt\n\nimport data.nat.basic -- hide\nimport tactic -- hide\nnamespace nat -- hide\n\n/-\nHier hast du eine weitere lineare Gleichung $a+2=4$. Als Beweisziel ist aber\nnicht der Wert von $a$ gesucht, sonder von $a+3$. Das schafft zwar `linarith`\nauch direkt (probier es gerne aus!), wir wollen aber die Gelegenheit nutzen\num zu erkl\u00e4ren, wie man sich in Beweisen Zwischenziele setzen kann.\n\nIn diesem Beweis k\u00f6nnte es zum Beispiel sinnvoll sein, die Hypothese `ha : a=2`\nzu beweisen und diese zu verwenden, `a` mit `rw ha,` in den Beweiszustand einzusetzen.\nUm sich eine Hypothese als Zwischenziel vorzunehmen verwendet man die Tactic `have`.\nDazu schreibt man:\n```\nhave ha : a = 2,\n{...},\n```\nMan f\u00fchrt die Hypothese ha ein, die im weiterem Verlauf verwendet werden kann. Dazu muss\nsie aber in den Klammern bewiesen werden.\n\nIn diesem Level k\u00f6nnte der Beweis dann so aussehen:\n```\nhave ha : a = 2,\n{sorry,}, -- Beweise ha, du kannst dazu linarith verwenden\nsorry,    -- Beweise nun mithilfe von ha den Beweiszustand\n```\nKopiere diesen Code und erg\u00e4nze die beiden sorry.\n-/\n\n/- Theorem\nSei $a \\in \\mathbb{N}$ mit $a+2=4$. Dann ist $a + 3=5$.\n-/\ntheorem lin_gl_zwischenschritt (a : \u2115) (h : a + 2 = 4): a + 3=5 :=\nbegin\n", "proof": "have ha : a = 2,\n{linarith,},\nrw ha,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : have\n## Anleitung\nDie Taktik have in Lean erlaubt es, einen Zwischenschritt w\u00e4hrend eines Beweises \nzu definieren, welches bewiesen werden soll um im restlichem Beweis verwendet\nzu werden.\n## Beispiel\nBei folgendem Zustand:\n```\na: \u2115\nh: a + 2 = 4\n\u22a2 a + 3 = 5\n```\nwird \n```\nhave ha : a = 2,\n{...},\n```\ndas Ziel ha einf\u00fchren, welches in den Klammern bewiesen werden soll und dann\nim Verlauf des Beweises verwendet werden darf.\n-/\n\nend nat -- hide", "height": 5, "editorText": "sorry", "lineOffset": 37, "name": "lin_gl_zwischenschritt", "statement": "(a : \u2115) (h : a + 2 = 4): a + 3=5"}, {"type": "tactic", "content": "136", "name": "have", "sideBar": true}, {"type": "lean", "content": "137", "hidden": true}]}, {"name": "138", "problemIndex": 6, "objects": [{"type": "lean", "content": "139", "hidden": true}, {"type": "lean", "content": "140", "hidden": true}, {"type": "lean", "content": "141", "hidden": true}, {"type": "lean", "content": "142", "hidden": true}, {"type": "lean", "content": "143", "hidden": true}, {"type": "text", "content": "144"}, {"type": "theorem", "text": "145", "lean": "theorem LGS_1 (a b : \u2115) (h : a+b=8 \u2227 b=3) : a=5 :=\n", "sideBar": true, "firstProofLineNumber": 40, "lastProofLineNumber": 42, "textBefore": "-- Level name : Lineares Gleichungssystem\n\n-- namespace nat -- hide \n\nimport data.nat.basic -- hide\nimport tactic -- hide\nimport mynat.one_eq -- hide\nnamespace nat -- hide\n\n/-\nWir schauen uns nun ein lineares Gleichungssystem an. Gegeben ist:\n```\na + b = 8\nb = 3\n```\nUnd zu zeigen ist, dass `a=5`. Auch hier k\u00f6nnte man direkt `linarith` anwenden\nund w\u00e4re fertig. Wir wollen uns aber die Frage stellen, wie wir eine hypothese\nwie `h`, die ein \"und\" (`\u2227`) enth\u00e4lt in zwei hypothesen einteilen kann, damit man\nsie einzeln verwenden kann.\n\nDazu gibt es die Tactic `cases`. F\u00fcr eine hypothese `h : h1 \u2227 h2` teilt `cases h with f g,`\ndie hypothese auf, sodass man die hypothesen `f : h1` und `g : h2` erh\u00e4lt. Die Namen der\nneuen Hypothesen k\u00f6nnen wir hier (`f g`) explizit angegeben werden oder werden ansonsten\nvon LEAN vergeben.\n\nWir werden in diesem Level so vorgehen, dass wir die hypothese aufteilen um `b=3` in \n`a+b=8` einzusetzten. Daf\u00fcr kannst du folgenden Schritte in deinem Beweis machen:\n1. Teile `h` auf. Du kannst die neuen hypothesen `hab` und `ha` nennen, um anzudeuten,\ndass `hab` die Gleichung ist die sowohl `a` wie auch `b` enth\u00e4lt und `ha` nur `a`.\n2. Setzte mithilfe von `rw` die Gleichung `hb` in `hab` ein.\n3. Nutze `linarith` um mit Umformungen den Beweis zu beenden.\n-/\n\n\n/- Theorem\nSeien $a, b \\in \\mathbb{N}$ mit $a+b=8$ und $b=3$. Dann ist $a=5$.\n-/\ntheorem LGS_1 (a b : \u2115) (h : a+b=8 \u2227 b=3) : a=5 :=\nbegin\n", "proof": "cases h with hab hb,\nrw hb at hab,\nlinarith,", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : cases\n## Anleitung\nF\u00fcr eine hypothese `h : h1 \u2227 h2` teilt `cases h with f g,`\ndie hypothese auf, sodass man die hypothesen `f : h1` und `g : h2` erh\u00e4lt.\n## Beispiel\nBei folgendem Zustand:\n```\nab: \u2115\nh: a + b = 8 \u2227 b = 3\n\u22a2 a = 5\n```\nf\u00fchrt `cases h with hab hb,` zu:\n```\nab: \u2115\nhab: a + b = 8\nhb: b = 3\n\u22a2 a = 5\n```\n.\n-/\n\nend nat -- hide", "height": 3, "editorText": "sorry", "lineOffset": 39, "name": "LGS_1", "statement": "(a b : \u2115) (h : a+b=8 \u2227 b=3) : a=5"}, {"type": "tactic", "content": "146", "name": "cases", "sideBar": true}, {"type": "lean", "content": "147", "hidden": true}]}, {"name": "148", "problemIndex": 5, "objects": [{"type": "lean", "content": "149", "hidden": true}, {"type": "lean", "content": "150", "hidden": true}, {"type": "lean", "content": "151", "hidden": true}, {"type": "lean", "content": "152", "hidden": true}, {"type": "text", "content": "153"}, {"type": "theorem", "text": "154", "lean": "theorem LGS_2 (a b : \u2115) (h : a+b+3=8 \u2227 a=b+1) : a=3 \u2227 b=2 :=\n", "sideBar": true, "firstProofLineNumber": 41, "lastProofLineNumber": 43, "textBefore": "-- Level name : Lineares Gleichungssystem - Teil 2\n\n-- namespace nat -- hide \n\nimport data.nat.basic -- hide\nimport tactic -- hide\nnamespace nat -- hide\n\n/-\nIn diesem Level m\u00f6chten wir ein letztes Gleichungssystem einf\u00fchren.\n```\na+b+3=8\na=b+1\n```\nEs soll gezeigt werden, dass die L\u00f6sung\n```\na=3\nb=2\n```\nist. In diesem Fall k\u00f6nnen wir nicht linarith direkt anwenden, weil in\nunserem Beweisziel ein \"und\" (`\u2227`) ist. Man kann aber ein Ziel, welches\nein \"und\" (`\u2227`) enth\u00e4lt mit der Tactic `split` in zwei Unterziele einteilen.\nIn unserem Fall wird mit `split,` das Ziel `a=3 \u2227 b=2` zu den Zielen\n`a=3` und `b=2`. Wie beim Induktionsbeweis kannst du die beiden Ziele\nin getrennten Umgebungen mit Klammern {} einteilen. Das Ger\u00fcst f\u00fcr diesen\nBeweis ist also \n```\nsplit,\n{sorry,},\n{sorry,},\n```\nKopiere dieses Ger\u00fcst, schau dir an was der erste Schritt bewirkt und\nersetze dann die beiden `sorry` mit Beweisen.\n-/\n\n/- Theorem\nSeien $a, b \\in \\mathbb{N}$ mit $a+b+3=8$ und $a=b+1$. Dann ist $a=3$ und $b=2$.\n-/\ntheorem LGS_2 (a b : \u2115) (h : a+b+3=8 \u2227 a=b+1) : a=3 \u2227 b=2 :=\nbegin\n", "proof": "split,\n{linarith,},\n{linarith,},", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Du wei\u00dft nicht wie du die Beweise an der Stelle der `sorry` f\u00fchren sollst?\nJetzt wo die Ziele jeweils nur einzelne Gleichungen sind kannst du `linarith` verwenden.\n-/\n\n/- Tactic : split\n## Anleitung\nMan kann aber ein Ziel, welches\nein \"und\" (`\u2227`) enth\u00e4lt mit der Tactic `split` in zwei Unterziele einteilen.\n## Beispiel\nFolgendem Zustand:\n```\nab: \u2115\nh: a + b + 3 = 8 \u2227 a = b + 1\n\u22a2 a = 3 \u2227 b = 2\n```\nwird durch `split,` zu:\n```\nab: \u2115\nh: a + b + 3 = 8 \u2227 a = b + 1\n\u22a2 a = 3\nab: \u2115\nh: a + b + 3 = 8 \u2227 a = b + 1\n\u22a2 b = 2\n```\n-/\nend nat -- hide", "height": 3, "editorText": "sorry", "lineOffset": 40, "name": "LGS_2", "statement": "(a b : \u2115) (h : a+b+3=8 \u2227 a=b+1) : a=3 \u2227 b=2"}, {"type": "lean", "content": "155", "hidden": false}, {"type": "tactic", "content": "156", "name": "split", "sideBar": true}, {"type": "lean", "content": "157", "hidden": true}]}], "parents": [0]}, {"name": "158", "levels": [{"name": "159", "problemIndex": 8, "objects": [{"type": "lean", "content": "160", "hidden": true}, {"type": "lean", "content": "161", "hidden": true}, {"type": "lean", "content": "162", "hidden": true}, {"type": "axiom", "content": "163", "name": "mul_zero (a : N) :", "sideBar": true}, {"type": "axiom", "content": "164", "name": "mul_succ (a b : N) :", "sideBar": true}, {"type": "text", "content": "165"}, {"type": "hint", "content": "166", "title": "167"}, {"type": "text", "content": "168"}, {"type": "theorem", "text": "169", "lean": "theorem zero_mul (a: N) : 0*a = 0 :=\n", "sideBar": true, "firstProofLineNumber": 60, "lastProofLineNumber": 68, "textBefore": "-- Level name : Die Multiplikation\n\nimport mynat.mul -- hide\nimport game.Addition.level_8 --hide\nnamespace N -- hide\n\n/- Axiom : mul_zero (a : N) :\na * 0 = 0\n-/\n\n/- Axiom : mul_succ (a b : N) :\na * succ(b) = a*d+a\n-/\n\n/-\nMan kann auch die Multiplikation zweier nat\u00fcrlichen Zahlen rekursiv anhand der \nPeano-Axiome definieren.\n- F\u00fcr $a \\in \\mathbb{N}$ sei $a*0=0$\n- F\u00fcr $a,d \\in \\mathbb{N}$ sei $a* $`succ`$(d) = a*d+a$\n\nNach dem Prinzip der Induktion ist dann die Multiplikation f\u00fcr alle Paare von\nnat\u00fcrlichen Zahlen definiert.\n\nDie beiden Aussagen, die die Multiplikation definieren, sind in LEAN implementiert und \nhaben jeweils den Namen `mul_zero` und `mul_succ`.\n-/\n\n/- Hint : Klicke hier, um die Definition der Multiplikation der nat\u00fcrlichen Zahlen in LEAN zu sehen. Du musst diesen Code nicht zu 100% verstehen.\nDefinition: <br>\n`def mul : N \u2192 N \u2192 N` <br>\n`| a zero := zero` <br>\n`| a (succ d) := mul a d + a` <br>\n\nDen beiden definierenden Eigenschaften wird ein Namen gegeben: <br>\n`lemma mul_zero (a : N) : a * zero = zero := rfl` <br>\n`lemma mul_succ (a d : N) : a * (succ d) = a * d + a := rfl`\n-/\n\n/-\nWir werden in den n\u00e4chsten Levels wieder grundlegende Rechenregeln beweisen. Dazu werden\nwir wieder ohne `linarith` arbeiten.\nIn diesem Level werden wir zeigen, dass auch die Multiplikation mit $0$ von links $0$ ergibt.\nWir haben die Kommutativit\u00e4t der Multiplikation noch nicht gezeigt. Da die Definition\nder Multiplikation sehr \u00e4hnlich zu der der Addition ist, wird auch dieser Beweis sehr \u00e4hnlich\nzu dem Beweis $0+a=0$ (Addition - Level 4) sein, du kannst diesen als Fahrplan verwenden:\n```\ninduction a with d hd,\n{rw N_zero_eq_zero,\nrw add_zero,},\n{rw add_succ,\nrw hd,},\n```\n-/\n\n/- Theorem\nSei $a \\in \\mathbb{N}$. Dann ist $0*a=0$.\n-/\ntheorem zero_mul (a: N) : 0*a = 0 :=\nbegin\n", "proof": "induction a with d hd,\n{rw N_zero_eq_zero,\nrw mul_zero,},\n{rw mul_succ,\nrw hd,\nrw add_zero,},\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide", "height": 9, "editorText": "sorry", "lineOffset": 59, "name": "zero_mul", "statement": "(a: N) : 0*a = 0"}, {"type": "lean", "content": "170", "hidden": true}]}, {"name": "171", "problemIndex": 6, "objects": [{"type": "lean", "content": "172", "hidden": true}, {"type": "lean", "content": "173", "hidden": true}, {"type": "lean", "content": "174", "hidden": true}, {"type": "text", "content": "175"}, {"type": "hint", "content": "176", "title": "177"}, {"type": "text", "content": "178"}, {"type": "theorem", "text": "179", "lean": "theorem succ_mul (a b : N) : succ(a) * b = a * b + b :=\n", "sideBar": true, "firstProofLineNumber": 45, "lastProofLineNumber": 56, "textBefore": "-- Level name : Multiplikation mit dem Nachfolger - von links\n\nimport mynat.mul -- hide\nimport game.Multiplikation.level_1 --hide\nnamespace N -- hide\n\n/-\nIn diesem Level werden wir zeigen, dass $(a+1)*b=a*b+b$, ist, oder mit `succ`\nausgedr\u00fcckt: `succ(a) * b = a * b + b`. Du kannst diesen Beweis wieder \u00fcber\nInduktion l\u00f6sen.\n-/\n\n/- Hint : Ist die Induktion \u00fcber `a` oder \u00fcber `b` geschickter?\nBei `a` als Induktionsvariable h\u00e4ttest du im Induktionsschritt `succ(succ(a))*b=succ(a)*b+b`.\nHier wird es schwer sein so umzuformen, dass man die Induktionsvoraussetzung verwenden kann,\nweil wir bis jetzt nur `mul_succ` verwenden k\u00f6nnen, welches angewandt werden kann\nwenn im zweiten Faktor `succ` vorkommt. Daf\u00fcr eignet sich `b` als Induktionsvariable,\nweil genau dann beim Induktionsschritt `succ` im zweiten Faktor vorkommt.\n-/\n\n/-\nDu kannst mit diesem Beweisger\u00fcst starten. Zu erg\u00e4nzen ist:\n1. Die Induktionsvariable\n2. Der Induktionsanfang\n3. Die Umformungen zu Beginn des Induktionsschrittes, die gemacht werden m\u00fcssen damit\ndie Induktionsvorraussetzung `hd` verwendet werden kann.\n\n```\ninduction Induktionsvariable with d hd,\n{rw N_zero_eq_zero,\nsorry,},\n{sorry,\nrw hd,\nrepeat {rw add_succ,},\nrw add_right_comm,\n},\n```\n-/\n\n/- Theorem\nSeien $a, b \\in \\mathbb{N}$. Dann ist `succ`$(a) * b = a * b + b$.\n-/\ntheorem succ_mul (a b : N) : succ(a) * b = a * b + b :=\nbegin\n", "proof": "induction b with d hd,\n{rw N_zero_eq_zero,\nrepeat {rw mul_zero,},\nrw add_zero,},\n{repeat {rw mul_succ,},\nrw hd,\nrepeat {rw add_succ,},\nrw add_right_comm,\n},\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide", "height": 12, "editorText": "sorry", "lineOffset": 44, "name": "succ_mul", "statement": "(a b : N) : succ(a) * b = a * b + b"}, {"type": "lean", "content": "180", "hidden": true}]}, {"name": "181", "problemIndex": 5, "objects": [{"type": "lean", "content": "182", "hidden": true}, {"type": "lean", "content": "183", "hidden": true}, {"type": "lean", "content": "184", "hidden": true}, {"type": "text", "content": "185"}, {"type": "hint", "content": "186", "title": "187"}, {"type": "theorem", "text": "188", "lean": "theorem mul_comm (a b : N) : a * b = b * a :=\n", "sideBar": true, "firstProofLineNumber": 32, "lastProofLineNumber": 41, "textBefore": "-- Level name : Kommutativit\u00e4t der Multiplikation\n\nimport mynat.mul -- hide\nimport game.Multiplikation.level_2 -- hide\nnamespace N -- hide\n\n/- \nDie Ergebnisse aus Level 1 und 2 sind genug, um die Kommutativit\u00e4t der Multiplikation\nzu zeigen! Hier ist zur Erinnerung der Beweis der Kommutativit\u00e4t der Addition:\n```\ninduction b with d hd,\n{rw N_zero_eq_zero,\nrw add_zero a,\nrw zero_add a,},\n{rw add_succ a,\nrw hd,\nrw succ_add d,},\n```\n-/\n\n/- Hint :  Aufgabe nach dem L\u00f6sen des Lean-Beweises\nVielleicht ist dir aufgefallen, dass man in dem Beweis aus der Addition nur\n\u00fcberall `add` mit `mul` ersetzten musste. Wie sieht in normaler mathematischen \nSprache aus? Formuliere dazu die Beweise add_comm und mul_comm schriftlich aus.\n-/\n\n/- Theorem\nSeien $a, b \\in \\mathbb{N}$. Dann ist a * b = b * a\n-/\ntheorem mul_comm (a b : N) : a * b = b * a :=\nbegin\n", "proof": "induction b with d hd,\n{rw N_zero_eq_zero,\nrw mul_zero,\nrw zero_mul,},\n{rw mul_succ,\nrw hd,\nrw succ_mul,},\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide", "height": 10, "editorText": "sorry", "lineOffset": 31, "name": "mul_comm", "statement": "(a b : N) : a * b = b * a"}, {"type": "lean", "content": "189", "hidden": true}]}, {"name": "190", "problemIndex": 4, "objects": [{"type": "lean", "content": "191", "hidden": true}, {"type": "lean", "content": "192", "hidden": true}, {"type": "lean", "content": "193", "hidden": true}, {"type": "text", "content": "194"}, {"type": "theorem", "text": "195", "lean": "theorem left_distrib (a b c : N) : c * (a + b) = c * a + c * b :=\n", "sideBar": true, "firstProofLineNumber": 22, "lastProofLineNumber": 34, "textBefore": "-- Level name : Das Distributivgesetz\n\nimport mynat.mul -- hide\nimport game.Multiplikation.level_3 -- hide\nnamespace N -- hide\n\n/-\nDas Distributivgesetz gibt uns an, wie wir mit Ausdr\u00fccken umgehen k\u00f6nnen, in denen\nAddition und Multiplikation vorkommen. Wir werden hier die \"Linksdistributivit\u00e4t\"\nzeigen, also $c*(a+b)=c*a+c*b$, daraus folgt aber nicht direkt $(a+b)*c=a*c+b*c$.\n\nIn diesem Level startest du den Beweis selber. Denk daran, dass bei Indukzion\noft der Schritt `rw N_zero_eq_zero,` n\u00f6tig ist. Wenn du nicht weiterkommst sind\nunter der Aufgabe Hinweise.\n-/\n\n/- Theorem\nSeien $a, b, c \\in \\mathbb{N}$. Dann ist $c * (a + b) = c * a + c * b$.\n-/\ntheorem left_distrib (a b c : N) : c * (a + b) = c * a + c * b :=\nbegin\n", "proof": "induction b with d hd,\n{rw N_zero_eq_zero,\nrw add_zero,\nrw mul_zero,\nrw add_zero,},\n{rw add_succ,\nrw mul_succ,\nrw hd,\nrw mul_succ,\nrw add_assoc,},\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Hint :  Hinweis: Beweisstruktur\n```\ninduction Induktionsvariable with d hd,\n{rw N_zero_eq_zero,\nsorry,},\n{sorry,},\n```\n-/\n\n/- Hint :  Induktionsvariable\nVerwende `b` als Induktionsvariable.\n-/\n\n/- Hint :  Hinweis: Ben\u00f6tigte Tactics und S\u00e4tze\nDu ben\u00f6tigst in diesem Beweis nur die `induction` und `rw` tactics. `rw` wendest du\nauf die Induktionshypothese und folgende S\u00e4tze an: `N_zero_eq_zero`, `add_zero`, `mul_zero`,\n`add_succ`, `mul_succ`, `add_assoc`. \n-/\n\nend N -- hide", "height": 13, "editorText": "sorry", "lineOffset": 21, "name": "left_distrib", "statement": "(a b c : N) : c * (a + b) = c * a + c * b"}, {"type": "hint", "content": "196", "title": "197"}, {"type": "hint", "content": "198", "title": "199"}, {"type": "hint", "content": "200", "title": "201"}, {"type": "lean", "content": "202", "hidden": true}]}, {"name": "203", "problemIndex": 5, "objects": [{"type": "lean", "content": "204", "hidden": true}, {"type": "lean", "content": "205", "hidden": true}, {"type": "lean", "content": "206", "hidden": true}, {"type": "text", "content": "207"}, {"type": "hint", "content": "208", "title": "209"}, {"type": "theorem", "text": "210", "lean": "theorem mul_assoc (a b c : N) : (a * b) * c = a * (b * c) :=\n", "sideBar": true, "firstProofLineNumber": 29, "lastProofLineNumber": 37, "textBefore": "-- Level name : Assoziativit\u00e4t der Multiplikation\n\nimport mynat.mul -- hide\nimport game.Multiplikation.level_4 -- hide\nnamespace N -- hide\n\n/-\nZuletzt Beweisen wir die Assoziativit\u00e4t der Multiplikation. Schau dir dazu zun\u00e4chst\nwieder den Beweis der Assoziativit\u00e4t der Addition an:\n```\ninduction c with d hd,\n{rw N_zero_eq_zero,\nrepeat{rw add_zero,},},\n{repeat{rw add_succ,},\nrw hd,},\n```\n-/\n\n/- Hint :  Kannst du auch bei der Assoziativit\u00e4t den Beweis aus der Addition einfach \u00fcbernehmen?\nNein, f\u00fcr diesen Beweis brauchst du n\u00e4mlich das Distributivgesetz. Das kommt daher, dass die \nDefinition der Multiplikation von der Addition abh\u00e4ngt (`a*succ(d)=a*d+a`).\n-/\n\n/- Theorem\nSeien $a, b, c \\in \\mathbb{N}$. Dann ist $(a * b) * c = a * (b * c)$.\n-/\ntheorem mul_assoc (a b c : N) : (a * b) * c = a * (b * c) :=\nbegin\n", "proof": "induction c with d hd,\n{rw N_zero_eq_zero,\nrepeat {rw mul_zero,},},\n{repeat{rw mul_succ},\nrw left_distrib,\nrw hd,},\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide", "height": 9, "editorText": "sorry", "lineOffset": 28, "name": "mul_assoc", "statement": "(a b c : N) : (a * b) * c = a * (b * c)"}, {"type": "lean", "content": "211", "hidden": true}]}, {"name": "212", "problemIndex": 5, "objects": [{"type": "lean", "content": "213", "hidden": true}, {"type": "lean", "content": "214", "hidden": true}, {"type": "lean", "content": "215", "hidden": true}, {"type": "lean", "content": "216", "hidden": true}, {"type": "text", "content": "217"}, {"type": "theorem", "text": "218", "lean": "theorem mul_gerade (a b : \u2115) (hger : \u2203 c : \u2115, a=2*c) : \u2203 d : \u2115, a*b = 2*d :=\n", "sideBar": true, "firstProofLineNumber": 43, "lastProofLineNumber": 46, "textBefore": "-- Level name : Multiplikation mit einer geraden Zahl ergibt eine gerade Zahl\n\n-- namespace nat -- hide \n\nimport data.nat.basic -- hide\nimport tactic -- hide\nnamespace nat -- hide\n\n/-\nNun haben wir alle grundlegenden Eigenschaften der Addition und Multiplikation gezeigt.\nDu darfst also insbesondere `linarith` wieder verwenden. \n\nIn diesem Level werden wir zeigen, dass die Multiplikation mit einer geraden Zahl\neine gerade Zahl ergibt. Also: Seien $a, b$ nat\u00fcrliche Zahlen. Falls es eine nat\u00fcrliche\nZahl $c$ gibt, sodass $a=2*c$ ,\ndann gibt es eine mat\u00fcrliche Zahl $d$, sodass $a*b=2*d$.\n\nDa die Existenz von dem $d$ gezeigt wird, wirst du wieder die Tactic `use` brauchen,\ndie wir bereits in anderen Existenzbeweisen gesehen haben. Nun hast du aber auch\neine Existenzaussage in den Voraussetzungen. Du wirst in deinem Beweis das konkrete\n$c$ f\u00fcr das $a=2*c$ gilt brauchen. Dazu kannst du die Tactic `obatin` verwenden. Diese\nverwendet die Existenzaussage um eine Variable $c$ einzuf\u00fchren und die Aussage, dass\nf\u00fcr dieses c $a=2*c$ gilt. Konkret:\n\nF\u00fcr die Aussage `(hger : \u2203 c : \u2115, a=2*c)`, wird `obtain \u27e8c, ager\u27e9 := hger,` folgendendes\nim Zustand erg\u00e4nzen:\n```\nc : N\nager : a=2*c\n```\nDabei sind die Argumente in den Klammern die Namen, die jeweil die Variable und die\nAussage bekommen sollen und das Argument nach dem `:=` die Existenzaussage.\n\nDu kannst den folgenden Beweis mit dieser Zeile starten.\n-/\n\n/- Theorem\nSeien $a, b \\in \\mathbb{N}$. Falls es ein $c \\in \\mathbb{N}$ gibt, sodass $a=2*c$ ,\ndann gibt es ein $d \\in \\mathbb{N}$, sodass $a*b=2*d$.\n-/\ntheorem mul_gerade (a b : \u2115) (hger : \u2203 c : \u2115, a=2*c) : \u2203 d : \u2115, a*b = 2*d :=\nbegin\n", "proof": "  obtain \u27e8c, ager\u27e9 := hger,\n  use [c*b],\n  rw ager,\n  rw mul_assoc,", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : obtain\n## Anleitung\nObtain (`obtain \u27e8c, hc\u27e9 := h,`) verwendet die Existenzaussage `h : \u2203 c : \u2115, hc` um eine \nVariable `c` und die entsprechende Aussage `hc` (h im konkretem Fall von `c`) einzuf\u00fchren.\n## Beispiel\nBei folgendem Zustand:\n```\na b: \u2115\nhger: \u2203 (c : \u2115), a = 2 * c\n\u22a2 \u2203 (d : \u2115), a * b = 2 * d\n```\nf\u00fchrt `obtain \u27e8c, ager\u27e9 := hger,` zu:\n```\na b c: \u2115\nager: a = 2 * c\n\u22a2 \u2203 (d : \u2115), a * b = 2 * d\n```\n-/\n\nend nat -- hide", "height": 4, "editorText": "sorry", "lineOffset": 42, "name": "mul_gerade", "statement": "(a b : \u2115) (hger : \u2203 c : \u2115, a=2*c) : \u2203 d : \u2115, a*b = 2*d"}, {"type": "tactic", "content": "219", "name": "obtain", "sideBar": true}, {"type": "lean", "content": "220", "hidden": true}]}], "parents": [1]}, {"name": "221", "levels": [{"name": "222", "problemIndex": 5, "objects": [{"type": "lean", "content": "223", "hidden": true}, {"type": "lean", "content": "224", "hidden": true}, {"type": "lean", "content": "225", "hidden": true}, {"type": "text", "content": "226"}, {"type": "hint", "content": "227", "title": "228"}, {"type": "theorem", "text": "229", "lean": "theorem kleiner_zwei : \u2203 a : \u2115, a \u2264 2 :=\n", "sideBar": true, "firstProofLineNumber": 40, "lastProofLineNumber": 41, "textBefore": "-- Level name : Ungleichungen\n\nimport data.nat.basic -- hide\nimport tactic -- hide\nnamespace nat -- hide \n\n/-\nNun werden wir uns mit Ungleichungen auseinandersetzen. Dazu wird als erstes $\u2264$\ndefiniert. Und zwar ist f\u00fcr nat\u00fcrliche Zahlen $a$ und $b$ $a\u2264b$ genau dann, wenn es\neine nat\u00fcrliche Zahl $c$ gibt, sodass $b=a+c$. Dieser Zusammenhang ist in Lean\nunter dem Satz `le_iff_exists_add` (`le` steht f\u00fcr \"less or equal\") gespeichert:\n\n`le_iff_exists_add (a b : \u2115) : a \u2264 b \u2194 \u2203 (c : \u2115), b = a + c`.\n\nDu kannst diesen Satz mit `rw` verwenden. Oft ist es aber sehr aufw\u00e4ndig eine\nUngleichung \u00fcber die Existenz eines `c` zu zeigen. Deswegen f\u00fchren wir hier die\nTactic `simp` ein. `simp` verwendet Gleichungen und Ungleichungen im Beweiszustand \num den Beweis zu vereinfachen oder zu beenden. Insbesondere kann `simp` ein\nBeweisziel wie `2\u22646` l\u00f6sen.\n\nIn diesem Level ist zu zeigen, dass es eine nat\u00fcrliche Zahl kleiner gleich $2$\ngibt. Beginne den Beweis, und sobal du ein Beweisziel der Form `a\u2264b` hast, verwende\n`simp`.\n-/\n\n/- Hint: Nach dem du den Beweis gel\u00f6st hast: wie w\u00e4re der Beweis ohne `simp`?\n```\nuse 1, -- Dieses use bezieht sich auf a\nrw le_iff_exists_add,\nuse [1], -- Dieses use bezieht such auf c\n```\n-/\n\n\n/- Theorem\nEs gibt ein $a \\in \\mathbb{N}$ mit $a\\leq2$.\n-/\ntheorem kleiner_zwei : \u2203 a : \u2115, a \u2264 2 :=\nbegin\n", "proof": "  use 1,\n  simp,", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : simp\n## Anleitung\n`simp` verwendet Gleichungen und Ungleichungen im Beweiszustand um den Beweis zu vereinfachen\noder zu beenden. Es kann entweder eine konkrete Aussage `h` \u00fcbergeben werden, die vereinfacht\nwerden soll (`simp [h],`) oder einfach `simp,` verwendet werden.\n## Beispiel\nBei folgendem Zustand:\n```\n\u22a2 1 < 2\n```\nl\u00f6st `simp,` den Beweis.\n-/\nend nat -- hide", "height": 2, "editorText": "sorry", "lineOffset": 39, "name": "kleiner_zwei", "statement": "\u2203 a : \u2115, a \u2264 2"}, {"type": "tactic", "content": "230", "name": "simp", "sideBar": true}, {"type": "lean", "content": "231", "hidden": true}]}, {"name": "232", "problemIndex": 5, "objects": [{"type": "lean", "content": "233", "hidden": true}, {"type": "lean", "content": "234", "hidden": true}, {"type": "lean", "content": "235", "hidden": true}, {"type": "lean", "content": "236", "hidden": true}, {"type": "text", "content": "237"}, {"type": "theorem", "text": "238", "lean": "theorem Pythagoreisches_Tripel : \u2203 a b c : \u2115, a*a+b*b=c*c :=\n", "sideBar": true, "firstProofLineNumber": 27, "lastProofLineNumber": 28, "textBefore": "-- Level name : Pythagoreisches Tripel\n\n-- namespace nat -- hide \n\nimport data.nat.basic -- hide\nimport tactic -- hide\nnamespace nat -- hide \n\n/-\nEin pythagoreisches Tripel besteht aus drei positiven nat\u00fcrlichen Zahlen $a$, $b$\nund $c$, die die Gleichung $a^2 + b^2 = c^2$ erf\u00fcllen. Diese Tripel sind besonders\nbekannt im Zusammenhang mit dem Satz des Pythagoras, der besagt, dass in einem \nrechtwinkligen Dreieck das Quadrat der Hypotenuse $c$ gleich der Summe der Quadrate\nder beiden Katheten $a$ und $b$ ist.\n\nIn diesem Level m\u00f6chten wir zeigen, dass ein solches Tripel existiert. Da wir keine\nPotenzen eingef\u00fchrt haben schreiben wir $a^2$ als $a*a$.\n-/\n\n\n\n/- Theorem\nEs gibt $a, b, c \\in \\mathbb{N}$ mit $a*a+b*b+c*c$.\n-/\ntheorem Pythagoreisches_Tripel : \u2203 a b c : \u2115, a*a+b*b=c*c :=\nbegin\n", "proof": "  use [3, 4, 5],\n  linarith,", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Hint: Kommst du nicht weiter?\nBei Existenzbeweisen brauchst du die Tactic `use`. Denk auch daran, dass du die Tactic\n`linarith` verwenden darfst um Ausdr\u00fccke zu vereinfachen.\n-/\n\nend nat -- hide", "height": 2, "editorText": "sorry", "lineOffset": 26, "name": "Pythagoreisches_Tripel", "statement": "\u2203 a b c : \u2115, a*a+b*b=c*c"}, {"type": "hint", "content": "239", "title": "240"}, {"type": "lean", "content": "241", "hidden": true}]}, {"name": "242", "problemIndex": 4, "objects": [{"type": "lean", "content": "243", "hidden": true}, {"type": "lean", "content": "244", "hidden": true}, {"type": "lean", "content": "245", "hidden": true}, {"type": "text", "content": "246"}, {"type": "theorem", "text": "247", "lean": "theorem gerades_quadrat : \u2203 a b c : \u2115, a=2*b \u2227 a=c*c :=\n", "sideBar": true, "firstProofLineNumber": 18, "lastProofLineNumber": 21, "textBefore": "-- Level name : Gerade Quadratzahl\n\nimport data.nat.basic -- hide\nimport tactic -- hide\nnamespace nat -- hide \n\n/-\nIn diesem Level m\u00f6chten wir zeigen, dass es eine gerade Quadratzahl gibt. Eine\nnat\u00fcrliche Zahl $a$ hei\u00df Quadratzahl, genau dann wenn es eine nat\u00fcrliche Zahl\n$b$ gibt, sodass $a=b^2$. In diesem Level werden wir das als `a=c*c` schreiben.\n-/\n\n/- Theorem\nEs gibt $a, b, c \\in \\mathbb{N}$ mit $a=2*b$ und $a=c*c$.\n-/\ntheorem gerades_quadrat : \u2203 a b c : \u2115, a=2*b \u2227 a=c*c :=\nbegin\n", "proof": "  use [16, 8, 4],\n  split,\n  {linarith,},\n  {linarith,},", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Wie war das nochmal mit Beweiszielen die `\u2227` beinhalten?\nSchau dir dazu die Tactic `split` an.\n-/\n\nend nat -- hide", "height": 4, "editorText": "sorry", "lineOffset": 17, "name": "gerades_quadrat", "statement": "\u2203 a b c : \u2115, a=2*b \u2227 a=c*c"}, {"type": "lean", "content": "248", "hidden": false}, {"type": "lean", "content": "249", "hidden": true}]}, {"name": "250", "problemIndex": 4, "objects": [{"type": "lean", "content": "251", "hidden": true}, {"type": "lean", "content": "252", "hidden": true}, {"type": "lean", "content": "253", "hidden": true}, {"type": "text", "content": "254"}, {"type": "theorem", "text": "255", "lean": "theorem neg_gr_vier (a : \u2115) (h : a \u2264 4) : \u00ac a > 4 :=\n", "sideBar": true, "firstProofLineNumber": 20, "lastProofLineNumber": 21, "textBefore": "-- Level name : Aussagen negieren\n\nimport data.nat.basic -- hide\nimport tactic -- hide\nnamespace nat -- hide \n\n/-\nIn diesem Level werden wir lernen, wie wir ein Beweisziel, welches mit einem\nNegationszeichen anf\u00e4ngt weiter vereinfachen. In deisem Level zum Beispiel ist\ndas Beweisziel `\u00ac a > 4`. Wir wissen, dass das equivalent zu `a \u2264 4` ist. Damit\nLean diese Umformung macht verwenden wir die Tactic `push_neg,`. Probier es zu\nBeginn dieses Beweises aus.\n-/\n\n/- Theorem\nSei $a \\in \\mathbb{N}$ mit $a\\leq4$. Dann gilt nicht, dass $a>4$.\n-/\ntheorem neg_gr_vier (a : \u2115) (h : a \u2264 4) : \u00ac a > 4 :=\nbegin\n", "proof": "push_neg,\nexact h,", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Wie schlie\u00df ich nochmal ein Beweisziel das gleich zu einer der gegebenen Aussagen ist?\nSchau dir dazu die Tactic `exact` an.\n-/\n\n/- Tactic : push_neg\n## Anleitung\n`push_neg` vereinfacht ein Beweisziel, welches mit einem Negationszeichen anf\u00e4ngt.\n## Beispiel\nWenn `push_neg` angewandt wird, wird:\n```\n\u22a2 \u00aca > 4\n```\nzu:\n```\n\u22a2 a \u2264 4\n```\n-/\n\nend nat -- hide", "height": 2, "editorText": "sorry", "lineOffset": 19, "name": "neg_gr_vier", "statement": "(a : \u2115) (h : a \u2264 4) : \u00ac a > 4"}, {"type": "lean", "content": "256", "hidden": false}, {"type": "tactic", "content": "257", "name": "push_neg", "sideBar": true}, {"type": "lean", "content": "258", "hidden": true}]}, {"name": "259", "problemIndex": 5, "objects": [{"type": "lean", "content": "260", "hidden": true}, {"type": "lean", "content": "261", "hidden": true}, {"type": "lean", "content": "262", "hidden": false}, {"type": "lean", "content": "263", "hidden": true}, {"type": "text", "content": "264"}, {"type": "theorem", "text": "265", "lean": "theorem no_small_mul_four : \u00ac\u2203 (a b : \u2115), b > 0 \u2227 a<4 \u2227 a = b*4 :=\n", "sideBar": true, "firstProofLineNumber": 48, "lastProofLineNumber": 55, "textBefore": "-- Level name : Der Widerspruchsbeweis\n\n-- namespace nat -- hide \n\nimport data.nat.basic -- hide\nimport tactic\nnamespace nat -- hide \n\n/-\nIn LEAN wird f\u00fcr einen Widerspruchsbeweis die Tactic `by_contra` verwendet.\nAngenommen, du m\u00f6chtest die Aussage P mit einem Widerspruchsbeweis beweisen, \nDu verwendest als erstes `by_contra` um den Widerspruchsbeweis zu starten.\nDu wirst sehen, dass nun `\u00acP` unter den gegebenen Aussagen ist, und das neue\nBeweisziel `\u22a2 false` ist. Das bedeutet, dass das Ziel ist, einen Widespruch zu\nerzeugen.\n\nEin Widerspruchsbeweis sieht also zum Beispiel so aus:\n\n```\ntheorem no_n_succ_eq_zero : \u00ac\u2203 (n : \u2115), n+1=0 :=\nbegin\nby_contra hex,\nobtain \u27e8n, hn\u27e9 := hex,\nlinarith,\nend\n```\nDabei kann man nach `by_contra` einen Namen (hier `hex`) f\u00fcr die Widerspruchsannahme geben.\n\nIn diesem Level werden wir mit einem Widerspruchsbeweis zeigen, dass es keine nat\u00fcrliche\nZahl $a<4$ gibt, die ein echtes Vielfaches von $4$ ist.\n\nUm den Lean beweis zu schreiben, kannst du diesen Beweis verwenden:\n1. Widerspruchsannahme: Angenommen es gibt $a, b \\in \\mathbb{N}$ mit $b>0$, $a<4$ und $a=b*4$.\n2. Seien nun $a, b \\in \\mathbb{N}$ sodass $b>0$, $a<4$ und $a=b*4$.\n3. Wir geben der Aussage $b>0$ den Namen hb, der Aussage $a<4$ den Namen ha und der Aussage\n$a=b*4$ den Namen hab.\n4. Wir zeigen nun zuerst, dass $a\\geq0$, indem wir die Aussage hnm und arithmetische\nOperationen verwenden.\n5. Mit dieser neuen Aussage und arithmentischen Operationen l\u00e4sst sich ein Widerspruch\nzur Aussage hn herleiten.\n-/\n\n/- Theorem\nEs gibt kein $a, b \\in \\mathbb{N}$ mit $b>0$, $a<4$ und $a=b*4$.\n-/\ntheorem no_small_mul_four : \u00ac\u2203 (a b : \u2115), b > 0 \u2227 a<4 \u2227 a = b*4 :=\nbegin\n", "proof": "by_contra h_contr,\nobtain \u27e8n, m, hnm\u27e9 := h_contr,\ncases hnm with hm hrest,\ncases hrest with hn hnm,\nhave n_bigger_four : n \u2265 4,\n{rw hnm,\nlinarith,},\nlinarith,", "proof_hint": "sorry", "textAfter": "\nend\n\n\n/- Tactic : by_contra\n## Anleitung\nWenn eine Aussage `P` zu beweisen ist, startet `by_contra` einen Widerspruchsbeweis\nindem `\u00acP` zu den gegebenen Aussagen hinzugef\u00fcgt wird und das Beweisziel zu `\u22a2 false` wird.\n## Beispiel\nFolgender Zustand:\n```\n\u22a2 \u00ac\u2203 (n : \u2115), n + 1 = 0\n```\nwird durch `by_contra hex,` zu \n```\nhex: \u2203 (n : \u2115), n + 1 = 0\n\u22a2 false\n```\n-/\nend nat -- hide", "height": 8, "editorText": "sorry", "lineOffset": 47, "name": "no_small_mul_four", "statement": "\u00ac\u2203 (a b : \u2115), b > 0 \u2227 a<4 \u2227 a = b*4"}, {"type": "tactic", "content": "266", "name": "by_contra", "sideBar": true}, {"type": "lean", "content": "267", "hidden": true}]}], "parents": [2]}, {"name": "268", "levels": [{"name": "269", "problemIndex": 4, "objects": [{"type": "lean", "content": "270", "hidden": true}, {"type": "lean", "content": "271", "hidden": true}, {"type": "lean", "content": "272", "hidden": true}, {"type": "text", "content": "273"}, {"type": "theorem", "text": "274", "lean": "theorem exist_divisor_rest_gr (n m : \u2115) (hm : m > 0) : \u2203 q r : \u2115, n = m * q + r :=\n", "sideBar": true, "firstProofLineNumber": 44, "lastProofLineNumber": 52, "textBefore": "-- Level name : Existenz Divisor und Rest - unbeschr\u00e4nktes $r$\n\nimport data.nat.basic -- hide\nimport tactic -- hide\nnamespace nat -- hide\n\n/-\nWir m\u00f6chten zuletzt noch zeigen, dass die Division mit Rest \u00fcber den nat\u00fcrlichen\nZahlen funktioniert. Das hei\u00dft, dass es f\u00fcr nat\u00fcrliche Zahlen $n, m$ mit $m>0$ gilt: \nEs gibt nat\u00fcrliche Zahlen $q, r$ mit $n = m*q + r$ und $r < m$.\n\nIn diesem Level werden wir zuerst eine abgeschw\u00e4chte Version zeigen, in der wir\nnicht fordern, dass $r < m$ ist. \n\nDazu werden wir lernen, wir mann in einem Beweis eine Fallunterscheidung macht. Wenn\nman in LEAN `by_cases h: a>4,` verwendet, dann teilt LEAN den Beweiszustand in zwei\nTeile. In beiden ist das Beweisziel das gleiche, in einem haben wir jedoch die\nAussage `h : a>4` und in dem anderen die Aussage `h : \u00ac a>4`. Wie bei anderen Tactics\ndie den Beweis aufteilen kannst du auch hier Klammern verwenden und somit folgende\nStruktur verwenden:\n```\nby_cases h: a>4,\n{},\n{},\n```\n\nVerwende f\u00fcr den Beweis in diesem Level folgendes Beweisger\u00fcst und erg\u00e4nze den\nInduktionsanfang, und die Beweise f\u00fcr die beiden F\u00e4lle, je nachdem ob d.succ ein\nVielfaches von m ist oder nicht:\n```\ninduction n with d hd,\n{ sorry, },\n{ by_cases hq : \u2203 q, d.succ = m*q,\n  { sorry, },\n  { sorry, }\n```\n-/\n\n/- Theorem\nSeien $n,m \u2208 \\mathbb{N}$ mit $m>0$. Dann gilt: Es gibt $q,r\\in \\mathbb{N}$ mit $n = m*q + r$.\n-/\ntheorem exist_divisor_rest_gr (n m : \u2115) (hm : m > 0) : \u2203 q r : \u2115, n = m * q + r :=\nbegin\n", "proof": "  induction n with d hd,\n  { use [0, 0],\n    simp [hm], },\n  { by_cases hq' : \u2203 q', d.succ = m*q',\n    { obtain \u27e8q', hq'\u27e9 := hq',\n      use [q', 0],\n      simp [hq'],},\n    { use [0, d.succ],\n      simp, } }", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : by_cases\n## Anleitung\n`by_cases h : ha,` startet eine Fallunterscheidung. In einem Fall gilt `h : ha` und im\nanderen gilt `h : \u00acha`. In beiden muss das urspr\u00fcngliche Beweisziel gezeigt werden.\n## Beispiel\nWenn\nman in LEAN `by_cases h: a>4,` verwendet, dann teilt LEAN den Beweiszustand in zwei\nTeile. In beiden ist das Beweisziel das gleiche, in einem haben wir jedoch die\nAussage `h : a>4` und in dem anderen die Aussage `h : \u00ac a>4`. Wie bei anderen Tactics\ndie den Beweis aufteilen kannst du auch hier Klammern verwenden und somit folgende\nStruktur verwenden:\n```\nby_cases h: a>4,\n{},\n{},\n```\n-/\n\nend nat -- hide", "height": 9, "editorText": "sorry", "lineOffset": 43, "name": "exist_divisor_rest_gr", "statement": "(n m : \u2115) (hm : m > 0) : \u2203 q r : \u2115, n = m * q + r"}, {"type": "tactic", "content": "275", "name": "by_cases", "sideBar": true}, {"type": "lean", "content": "276", "hidden": true}]}, {"name": "277", "problemIndex": 6, "objects": [{"type": "lean", "content": "278", "hidden": true}, {"type": "lean", "content": "279", "hidden": true}, {"type": "lean", "content": "280", "hidden": true}, {"type": "lean", "content": "281", "hidden": true}, {"type": "lean", "content": "282", "hidden": true}, {"type": "text", "content": "283"}, {"type": "theorem", "text": "284", "lean": "theorem lemma_div (m d q r : \u2115) (hr : r < m) (hq : d = m*q+r) (hq' : \u00ac \u2203 (q':\u2115), d.succ=m*q') : r+1<m :=\n", "sideBar": true, "firstProofLineNumber": 65, "lastProofLineNumber": 86, "textBefore": "-- Level name : Existenz Divisor und Rest\n\n-- namespace nat -- hide \n\nimport data.nat.basic -- hide\nimport tactic -- hide\nimport game.Division_mit_Rest.level_1 --hide\nnamespace nat -- hide \n\n/-\nBevor wir uns unserem finalem Level widmen, indem wir die Aussage der\nDivision mit Rest f\u00fcr $r < m$ zeigen, brauchen wir noch ein Lemma, das wir\nhier auslagern, damit der Beweis im n\u00e4chsten Level nicht so kompliziert\nwird. \n\nDas Lemma wird dazu nutzen, im Induktionsschritt des Beweises der Division\nmir Rest zu zeigen, dass $r < m$. Aus der Induktionsvoraussetzung haben wir:\n```\nhr : r < m\nhq : d = m*q+r\n```\nAu\u00dferdem wird dieses Lemma in einer Fallunterscheidung verwendet, in dem Fall\ndas `d.succ` kein Vielfaches von `m` ist, also:\n```\nhq' : \u00ac \u2203 (q':\u2115), d.succ=m*q'\n```\n\nIn diesem Level musst du den Beweus nicht selber machen aber solltest ihn lesen\nund nachvollziehen. Dazu kannst du den Beweis direkt in das Feld kopieren:\n```\n/- zuerst zeigen wir, dass r+1 \u2264 m (da r < m) -/\n  have hr_succ_le_m : r + 1 \u2264 m,\n  { exact succ_le_of_lt hr, },\n  /- nun f\u00fchren wir einen Widerspruchbeweis. Wenn wir n\u00e4mlich annehmen,\n  dass r+1 \u2265 m, dann k\u00f6nnen wir danach mir hr_succ_le_m Gleichheit folgern -/ \n  by_contra h_contr,\n  push_neg at h_contr,\n  /- nun folgern wir r+1=m -/\n  have hr1_m : r+1=m,\n  {exact le_antisymm hr_succ_le_m h_contr,}, \n  /- damit k\u00f6nnen wir zeigen, dass d+1=m*(q+1) ist -/\n  have d_mult_q : d.succ = m*(q+1),\n  {rw succ_eq_add_one,\n  linarith,\n  },\n  /- Um nun einen Widerspruch herzustellen m\u00fcssen wir dies noch\n  als Existenzaussage formulieren. -/\n  have h_eq : \u2203 (q : \u2115), d.succ = m * q := \u27e8q+1, d_mult_q\u27e9,\n  /- Wir haven nun zwei widerspr\u00fcchliche Aussagen im Beweiszustand.\n  Mit contradiction kann der Widerspruchsbeweis beender werden. -/\n  contradiction,\n```\nDie Kommentare f\u00fchren dich durch den Beweis. Es werden zwei S\u00e4tze verwendet,\ndie du nicht kennst. Hier ist ihre Bedeutung:\n`succ_le_of_lt {a b : \u2115} (h : a < b) : succ a \u2264 b` \n`le_antisymm : \u2200 {a b : \u2115}, (a \u2264 b \u2227 b \u2264 a) \u2192 a = b`\n-/\n\n/- Theorem\nSeien $m,d,q,r \u2208 \\mathbb{N}$ mit $r < m$ und $d=m*q+r$. Falls es kein $q' \u2208 \\mathbb{N}$ gibt\nsodass $d+1=m*q$, dann gilt, dass $r+1 < m$\n-/\ntheorem lemma_div (m d q r : \u2115) (hr : r < m) (hq : d = m*q+r) (hq' : \u00ac \u2203 (q':\u2115), d.succ=m*q') : r+1<m :=\nbegin\n", "proof": "  /- zuerst zeigen wir, dass r+1 \u2264 m (da r < m) -/\n  have hr_succ_le_m : r + 1 \u2264 m,\n  { exact succ_le_of_lt hr, },\n  /- nun f\u00fchren wir einen Widerspruchbeweis. Wenn wir n\u00e4mlich annehmen,\n  dass r+1 \u2265 m, dann k\u00f6nnen wir danach mir hr_succ_le_m Gleichheit folgern -/ \n  by_contra h_contr,\n  push_neg at h_contr,\n  /- nun folgern wir r+1=m -/\n  have hr1_m : r+1=m,\n  {exact le_antisymm hr_succ_le_m h_contr,}, \n  /- damit k\u00f6nnen wir zeigen, dass d+1=m*(q+1) ist -/\n  have d_mult_q : d.succ = m*(q+1),\n  {rw succ_eq_add_one,\n  linarith,\n  },\n  /- Um nun einen Widerspruch herzustellen m\u00fcssen wir dies noch\n  als Existenzaussage formulieren. -/\n  have h_eq : \u2203 (q : \u2115), d.succ = m * q := \u27e8q+1, d_mult_q\u27e9,\n  /- Wir haven nun zwei widerspr\u00fcchliche Aussagen im Beweiszustand.\n  Mit contradiction kann der Widerspruchsbeweis beender werden. -/\n  contradiction,\n        ", "proof_hint": "sorry", "textAfter": "\nend\n\nend nat -- hide", "height": 22, "editorText": "sorry", "lineOffset": 64, "name": "lemma_div", "statement": "(m d q r : \u2115) (hr : r < m) (hq : d = m*q+r) (hq' : \u00ac \u2203 (q':\u2115), d.succ=m*q') : r+1<m"}, {"type": "lean", "content": "285", "hidden": true}]}, {"name": "286", "problemIndex": 6, "objects": [{"type": "lean", "content": "287", "hidden": true}, {"type": "lean", "content": "288", "hidden": true}, {"type": "lean", "content": "289", "hidden": true}, {"type": "lean", "content": "290", "hidden": true}, {"type": "lean", "content": "291", "hidden": true}, {"type": "text", "content": "292"}, {"type": "theorem", "text": "293", "lean": "theorem exist_divisor_rest (m n : \u2115) (hm : m > 0) : \u2203 q r : \u2115, n = m * q + r \u2227 r < m :=\n", "sideBar": true, "firstProofLineNumber": 55, "lastProofLineNumber": 85, "textBefore": "-- Level name : Existenz Divisor und Rest\n\n-- namespace nat -- hide \n\nimport data.nat.basic -- hide\nimport tactic -- hide\nimport game.Division_mit_Rest.level_2 --hide\nnamespace nat -- hide \n\n/-\nNun k\u00f6nnen wir den Satz zum Beweis mit Rest zeigen. Dazu fehlt dir nur noch eine\nTactic, um das Lemma aus dem vorherigem Level anwenden zu k\u00f6nnen. Wenn die Voraussetzungen\neines anderen Satz in dem Beweiszustand gegeben sind und das Beweisziel das Ergebnis\ndieses Satzes ist, kann mit `apply Satz Voraussetzungen,` das Ziel gel\u00f6st werden.\n\nWenn man zum Beispiel der Satz:\n```\ntheorem mul_gerade (a b : \u2115) (hger : \u2203 c : \u2115, a=2*c) : \u2203 d : \u2115, a*b = 2*d\n```\nbereits bewiesen wurde und der Beweiszustand:\n```\nc d : \u2115\nhc: \u2203 (e : \u2115), c = 2 * e\n\u22a2 \u2203 (f : \u2115), c * d = 2 * f\n```\nist kann man `apply mul_gerade c d hc,` angewandt werden um den Beweis\nzu l\u00f6sen. Wichtig ist die Reihenfolge der Voraussetzungen, diese d\u00fcrfen\naber nat\u00fcrlich im neuen Kontext einen anderen Namen haben.\n\nIn diesem Level kannst du dich an der Struktur des vereinfachten Beweises orientieren:\n```\ntheorem exist_divisor_rest_gr (n m : \u2115) (hm : m > 0) : \u2203 q r : \u2115, n = m * q + r :=\nbegin\n  induction n with d hd,\n  { use [0, 0],\n    simp [hm], },\n  { by_cases hq' : \u2203 q', d.succ = m*q',\n    { obtain \u27e8q', hq'\u27e9 := hq',\n      use [q', 0],\n      simp [hq'],},\n    { use [0, d.succ],\n      simp, } }\nend\n\nmit dem Unterschied, dass du nach dem `use` Befehl nun eine Aussage mit `\u2227` zeigen\nmusst und hier also `split` verwenden solltest.\n```\n-/\n\n/- Theorem\nSeien $n,m \u2208 \\mathbb{N}$ mit $m>0$. Dann gilt: Es gibt $q,r\\in \\mathbb{N}$ mit $n = m*q + r$ und $r < m$.\n-/\ntheorem exist_divisor_rest (m n : \u2115) (hm : m > 0) : \u2203 q r : \u2115, n = m * q + r \u2227 r < m :=\nbegin\n", "proof": "  induction n with d hd,\n  { -- Induktionsanfang\n    use [0, 0],\n    split,\n    { -- Zeige: 0=m*0+0\n      simp, },\n    { -- Zeige: 0 kleiner m\n      exact hm, }, },\n  { -- Induktionsschritt\n    by_cases hq2 : \u2203 q', d.succ = m*q',\n    { -- Fall m teilt d+1\n      obtain \u27e8q, hq\u27e9 := hq2,\n      use [q, 0],\n      split,\n      { -- Zeige: d+1=m*q+0\n        simp [hq],\n        },\n      { -- Zeige: r kleiner m\n        exact hm, }, },\n    { -- Fall m teilt d+1 nicht\n      obtain \u27e8q, r, \u27e8hq, hr\u27e9\u27e9 := hd,\n      use [q, r + 1],\n      split,\n      { -- Zeige: d+1 = m * q + (r + 1)\n        rw hq,\n        rw add_succ, },\n      { -- Zeige r kleiner m\n        apply lemma_div m d q r hr hq hq2,\n        },\n    },\n  },", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : apply\n## Anleitung\nWenn die Voraussetzungen eines anderen Satz in dem Beweiszustand\ngegeben sind und das Beweisziel das Ergebnis dieses Satzes ist, kann\nmit `apply Satz Voraussetzungen,` das Ziel gel\u00f6st werden.\n## Beispiel\nWenn man zum Beispiel der Satz:\n```\ntheorem mul_gerade (a b : \u2115) (hger : \u2203 c : \u2115, a=2*c) : \u2203 d : \u2115, a*b = 2*d\n```\nbereits bewiesen wurde und der Beweiszustand:\n```\nc d : \u2115\nhc: \u2203 (e : \u2115), c = 2 * e\n\u22a2 \u2203 (f : \u2115), c * d = 2 * f\n```\nist kann man `apply mul_gerade c d hc,` angewandt werden um den Beweis\nzu l\u00f6sen. Wichtig ist die Reihenfolge der Voraussetzungen.\n-/\nend nat -- hide", "height": 31, "editorText": "sorry", "lineOffset": 54, "name": "exist_divisor_rest", "statement": "(m n : \u2115) (hm : m > 0) : \u2203 q r : \u2115, n = m * q + r \u2227 r < m"}, {"type": "tactic", "content": "294", "name": "apply", "sideBar": true}, {"type": "lean", "content": "295", "hidden": true}]}], "parents": [3]}], "texts": [["Einf\u00fchrung in den Theorembeweiser LEAN", "intro", "# Einf\u00fchrung in den Theorembeweiser LEAN\n## Worum geht es in dieser Lernumgebung?\n### Mathematisch \nIn der Schule lernen wir die nat\u00fcrlichen Zahlen kennen und wir lernen, wie \nwir mit ihnen elementare Rechenoperationen durchf\u00fchren. Dabei wird aber nicht \nauf die formale Definition eingegangen.\n\nIn dieser Einheit m\u00f6chten wir die Definition der nat\u00fcrlichen Zahlen nach Peano\nbetrachten. Grob gesagt entstehen damit die nat\u00fcrlichen Zahlen aus der 0 zusammen \nmit Rekursion. \u00dcber die Rekursion kann dann die Addition und Multiplikation definiert \nwerden. F\u00fcr diese Rechenoperationen werden wir dann die grundlegenden Eigenschaften \nwie Kommutativit\u00e4t und Assoziativit\u00e4t zeigen. Danach f\u00fchren wir das Konzept der \nUngleichungen ein, indem wir definieren, dass $a \\leq b$ genau dann, wenn ein \n$k \\in \\mathbb{N}$ existiert, sodass $a+k=b$. Diese Resultate verwenden wir um am Ende\nder Lernumgebung den Satz der Divion mit Rest zu zeigen, also:\n\nF\u00fcr alle $n,m \\in \\mathbb{N}$ mit $m>0$ gibt es $q,r \\in \\mathbb{N}$ mit $q < m$ und\n$n=q*m+r$.\n\n### Technologisch\nWir werden die Programmiersprache \n<a href=\"https://leanprover-community.github.io/\" target=\"blank\">LEAN</a> kennenlernen.\nLEAN ist ein interaktiver Theorembeweiser. In einem Theorembeweiser kann man\neinen Beweis Schritt f\u00fcr Schritt (in Computersprache) eingeben. Dieser \u00fcberpr\u00fcft\ndann, ob der Beweis korrekt ist und kann an jeder Stelle des Beweises Feedback zum\naktuellen Stand des Beweises geben.\n\n\n## Eine kurze Anleitung.\nMit diesem Tool kannst du an dieser Einheit arbeiten. Die Einheit ist in die Kapitel\nPeano, Addition, Multiplikation, Ungleichungen und Division mit Rest eingeteilt. Jedes\nKapitel hat mehrere Level. Am besten ist es, wenn du die Kapitel und Level der Reihe nach \nbearbeitest.\n\nIn jedem Level gibt es als Erstes einen Text, der den mathematischen Inhalt und die \nn\u00f6tigen LEAN-Anleitungen des Levels einf\u00fchrt. Darunter ist die zu l\u00f6sende Aufgabe:\nder Beweis eines Satzes, der in LEAN ausgef\u00fchrt werden soll. Oft musst du den Beweis\nnicht vollst\u00e4ndig selber machen, weil ein Ausgangs-Code ist in der Einf\u00fchrung gegeben\nist.\n\nDein Fortschritt wird im normalfall automatisch im Browser gespeichert. Wenn du \nvorsichtshalber deinen Stand speichern m\u00f6chtest klicke in diesem Fensters den \ud83d\udcbe Button \n\u00fcber dem Spielbaum. Damit wird dein Spielstand in einer json-Datei gespeichert. Diese \nkannst du beim n\u00e4chsten Mal hochladen, indem du den \ud83d\udcdd Button klickst. \n\nViel Spa\u00df beim Coden!\n\n## Du bist mit dem Tool fertig - was nun?\n\nDieses Tool ist inspiriert durch das \n<a href=\"https://www.ma.imperial.ac.uk/~buzzard/xena/natural_number_game/\" target=\"blank\">Natural Number Game</a>\nvon Kevin Buzzard. Du kannst dort andere Levels l\u00f6sen. Die LEAN Version dort\nist etwas \u00e4lter und einige Dinge funktionieren leicht anders, am besten solltest\ndu also die ersten paar Levels wieder l\u00f6sen, obwohl sie sehr \u00e4hnlich sind.\n", "Peano", "Die Peano Axiome", "import mynat.definition -- hide\n", "namespace N -- hide\n", "Die nat\u00fcrlichen Zahlen k\u00f6nnen mit Peanos Axiomen eindeutig definiert werden. Die\nAxiome lauten wie folgt:\n- $A_1$: $0$ (in LEAN entweder `0` oder `zero`) ist eine nat\u00fcrliche Zahl \n- $A_2$: Es gibt eine injektive Abbildung `succ`$: \\mathbb{N} \\to \\mathbb{N}$, die f\u00fcr jede nat\u00fcrliche Zahl ihren Nachfolger angibt.\n- $A_3$: $0$ ist nicht der Nachfolger einer nat\u00fcrlichen Zahl.\n- $A_4$: Das Prinzip der Induktion: Enth\u00e4lt eine Menge die $0$ und f\u00fcr jede enthaltene nat\u00fcrliche Zahl $n$ auch ihren Nachfolger `succ`$(n)$, so enth\u00e4lt sie alle nat\u00fcrlichen Zahlen.\n\nIn LEAN kann man die Anwendung der Abbildung `succ` auf `a` sowohl als `succ(a)` als auch \nals `a.succ` schreiben.\n", "Wir haben die Addition noch nicht definiert. Au\u00dferdem ist `succ`$(n)=n+1$ mit $1=$`succ`$(0)$ dann noch zu beweisen.\n", "Wieso brauchen wir hier die Abbildung `succ`, um den Nachfolger einer Zahl $n$ zu beschreiben, anstatt den Ausdruck n+1 zu verwenden?", "Aus diesen Axiomen werden wir alles herleiten und beweisen, was wir in dieser Einheit\nvorhaben. In diesem Level werden wir folgende Aussage zur Funktion `succ` zeigen: F\u00fcr die nat\u00fcrlichen Zahlen a und b gilt: falls `succ(a)=b` dann `succ(succ(a))=succ(b)`.\n\nDiese Aussage kann man direkt zeigen, indem man die gegebene Hypothese `succ(a)=b` in die\nzu zeigende Aussage `succ(succ(a))=succ(b)` einsetzt und somit `succ(b)=succ(b)` erh\u00e4lt.\n\nWir schauen uns nun an, wie das in LEAN funktioniert. Wir werden mit der Klasse\nN arbeiten, die genau die Menge der nat\u00fcrlichen Zahlen definiert nach den Peano-Axiomen \nist.\n", "`inductive N` \u2192 $A_4$ <br>\n`| zero : N` \u2192 $A_1$ <br>\n`| succ (n : N) : N` \u2192 $A_2$ <br>\n`lemma succ_inj {m n : N} (h : succ m = succ n) : m = n := by cases h; refl` \u2192 $A_2$ <br>\n`lemma zero_ne_succ (m : N) : (zero : N) \u2260 succ m := \u03bb h, by cases h` \u2192 $A_3$\n", "Klicke hier, um die Definition der nat\u00fcrlichen Zahlen in LEAN zu sehen. Du musst diesen Code nicht zu 100% verstehen.", "Als Erstes muss man das Lemma definieren, das man beweisen m\u00f6chte. Dies besteht aus drei \nTeilen.\n- Name: Der Name kann beliebig gew\u00e4hlt werden, ist im besten Fall aber eine gute \nBeschreibung des Lemmas. Hier kann man zum Beispiel \u201csucc_succ\u201d w\u00e4hlen, um anzudeuten, \ndass es um die Zweifachanwendung der Abbildung `succ` geht.\n- Voraussetzungen: Diese stehen zwischen dem Namen und dem Doppelpunkt. In diesem Fall\nsind das, dass a und b nat\u00fcrliche Zahlen sind und die Aussage h, dass `succ(a)=b`.\n- Folgerung: Diese steht zwischen dem Doppelpunkt und dem Definitionszeichen. In diesem\nFall also, `succ(succ(a))=b`.\n\nDer Beweis folgt zwischen dem `begin` und dem `end`. Zu Beginn der Bearbeitung steht im\nBeweis immer `sorry`. Dies ist ein Keyword, was so viel bedeutet wie: \"Hier fehlt ein\nTeil des Beweises\". Du kannst dieses Keyword verwenden, wenn ein Beweis \u00fcberpr\u00fcft werden\nsoll, bei dem dir noch ein Teil fehlt. LEAN wird best\u00e4tigen, dass der Beweis stimmt, aber\nmit dem warning \"uses `sorry`\" darauf hinweisen, dass noch etwas zu tun ist. L\u00f6sche als\nErstes das `sorry`, um mit dem Beweis zu starten.\n\nWir haben oben bereits beschrieben, wie der Beweis mathematisch funktioniert. Wie \n\u00fcbertragen wir die Idee in LEAN? Dazu gibt es den `rw` (rewrite) Befehl. Wenn `h` eine\nAussage ist (z.B. $a=b$), dann bewirkt `rw h,`, dass LEAN die Aussage `h` in der zu \nzeigenden Aussage einsetzt (im Beispiel w\u00fcrde also in der zu zeigenden Aussage jedes $a$\nmit einem $b$ ersetzt werden). Probiere also den Befehl `rw h,` aus. Das Komma am Ende \njedes LEAN-Befehls ist sehr wichtig. Wenn du Fehlermeldungen bekommst, die du nicht\nverstehst, \u00fcberpr\u00fcfe deinen Code auf fehlende Kommata.\n\nDie rechte Spalte:\nHier gibt LEAN dynamisches Feedback. Bis auf die letzte Zeile steht hier immer was \ngegeben ist, in diesem Fall zum Beispiel, dass a und b nat\u00fcrliche Zahlen sind und die\nAussage `h`. In der letzten Zeile, nach dem `\u22a2` Symbol, steht immer das aktuelle Ziel, \nalso das, was gerade zu  zeigen ist. Wenn man am Anfang des Beweises steht, ist das \nnoch die ganze Aussage des Lemmas. Nachdem man `rw h,` eingibt, sieht man, dass sich \nder Zustand \u00e4ndert. In diesem Fall kommt die Nachricht `Proof complete!`, die uns \nangibt, dass wir fertig sind. In l\u00e4ngeren Aufgaben w\u00fcrde hier das neue Ziel stehen. Ein\nBeweis ist dann zuende, wenn eine Aussage der Form \"a=a\" als Beweiszustand entsteht.\n", "Seien $a, b \\in \\mathbb{N}$. Falls `succ`$(a) = b$, dann `succ`$($`succ`$(a)) = $`succ`$(b)$.\n", "## Anleitung\nWenn `h` eine Aussage des Typs `X = Y` ist, dann wird\n`rw h,` alle `X` in der zu beweisenden Aussage durch\n`Y` austauschen.\nUm alle `Y` durch `X` zu ersetzten verwendet man `rw \u2190 h`.\n## Beispiel\nBei folgendem Zustand:\n```\nx : N\nh : x + 0 = 0\n\u22a2 succ (x + 0) = succ (x)\n```\nwird `rw h,` das Ziel um\u00e4ndern zu `\u22a2 succ (x) = succ (x)`,\nund damit den Beweis abschlie\u00dfen.\n## Erweitert\n1. Man kann einen konkreten Teil des Zustands konkretisieren,\num vorzugeben wo Lean `rw` anwenden soll. Bei dem Zustand:\n```\nx y : N\nh : x + 1 = y\n\u22a2 x + 0 + 1 = y + 0\n```\nwird `rw add_zero x,` den Zustand zu `x + 1 = y + 0` \u00e4ndern und\n`rw add_zero y,` zu `x + 0 + 1 = y`\n2. Man kann rw auch auf gegebene Hypothesen anwenden statt auf\nden Beweiszustand.Bei dem Zustand:\n```\nx : N\nh : x + 0 = 3\n\u22a2 x = 3 + 0\n```\nwird `rw add_zero at h,` den Beweiszustand nicht \u00e4ndern, daf\u00fcr aber\n`h` umformen zu `h : x = 3`\n", "end N -- hide", "Die Peano Axiome - Teil 2", "import mynat.definition -- hide\n", "import game.Peano.level_1 --hide\n", "namespace N -- hide\n", "In diesem Level passiert nicht viel. Es dient eher zur \u00dcbung von dem Gelernten in\nLevel 1 und um ein weiteres feature des `rw` Befehls zu verstehen.\n\nVielleicht hast du gemerkt, dass es eine linke Spalte gibt. Hier kannst du alle\nTools finden, die du zum Beweisen brauchst. Das sind einerseits die Befehle (wie\nz.B. `rw`), die in LEAN Tactics hei\u00dfen. Andererseits sind das die Axiome und Aussagen,\ndie wir bereits eingef\u00fchrt/bewiesen haben. Diese sind in der Kategorie Theorem\nstatements. Umso weiter du bist, umso mehr Inhalt wirst du hier finden.\n\nWir haben im vorherigem Level gesehen, dass f\u00fcr die Aussage `h: a = b` der Befehl\n`rw h,` in der zu zeigenden Aussage jedes `a` durch ein `b` ersetzt. Aber wie\nkann man jedes `b` durch ein `a` ersetzen? Dazu verwendet man den Befehl\n`rw \u2190 h,`. Der Pfeil steht sozusagen daf\u00fcr, dass LEAN die Aussage h von rechts\nnach links lesen soll. Du kannst den Pfeil mit \\ l (backslash + klein L)\nschreiben.\n\nDu kannst das untenstehende Lemma \u00e4hnlich wie Level 1 l\u00f6sen, aber erkennst du\nauch einen weiteren Weg der `\u2190` verwendet?\n", "Seien $a, b, c \\in \\mathbb{N}$. Falls `succ`$(a) = b$ und `succ`$(b)= c$, dann `succ`$($`succ`$(a)) = c$.\n", "end N -- hide\n", "In der zu zeigenden Aussage kommt der Term `c` vor, der auch Teil der Aussage\n`g` ist. Du kannst also mit `rw \u2190 g,` das `c` in der Aussage ersetzen.\n", "Brauchst du Hilfe, um einen zweiten Weg zu finden?", "Die Peano Axiome - Teil 3", "import mynat.definition -- hide\n", "import game.Peano.level_2 --hide\n", "namespace N -- hide\n", "In diesem Level werden wir wieder einen \u00e4hnlichen Satz wie im vorherigem Level\nl\u00f6sen. Wir m\u00f6chten aber dazu eine neue Eingeschaft der Tactic `rw` benutzen und\neine weitere Tactic kennenlernen.\n\nMan kann rw auch auf gegebene Hypothesen anwenden statt auf den Beweiszustand. Man\ngibt dazu mit `at hypothese` and, auf welche hypothese rw angewandt werden soll.\nBei folgendem Zustand, den wir aus dem vorherigem Level kennen:\n```\nx : N\nh : succ(a) = b\ng : succ(b) = c\n\u22a2 succ(succ(a)) = c\n```\nwird `rw \u2190 h at g,` den Beweiszustand nicht \u00e4ndern, daf\u00fcr aber `g` umformen zu \n`g : succ(succ(a))=c`. In diesem Beispiel h\u00e4tten wir dann eine Hypothese, die\nexakt gleich zu dem Beweiszustand ist. Um diese Hypothese zu verwenden um den\nBeweiszustand zu l\u00f6sen, k\u00f6nnen wir die `exact` tactic verwenden und den Beweis\nmit `exact g` schlie\u00dfen.\n\nDen Beweis in diesem Level kannst du ebenfalls mit `rw ... at ...,` und `exact...,`\nl\u00f6sen.\n", "Seien $a, b, c \\in \\mathbb{N}$. Falls `succ`$(a) = b$ und `succ`$($`succ`$(a)) = c$, dann `succ`$(b)= c$.\n", "## Anleitung\nWenn `h` eine Aussage ist, die exakt gleich zu dem Beweiszustand\nist, dann l\u00f6st `exact h` den Beweis.\n## Beispiel\nBei folgendem Zustand:\n```\nx y : N\nh : x + 1 = y\n\u22a2 x + 1 = y\n```\nl\u00f6st `exact h` den Beweis.\n", "end N -- hide\n", "In der zu zeigenden Aussage kommt der Term `c` vor, der auch Teil der Aussage\n`g` ist. Du kannst also mit `rw \u2190 g,` das `c` in der Aussage ersetzen.\n", "Brauchst du Hilfe, um einen zweiten Weg zu finden?", "Addition", "Die Addition", "-- namespace nat -- hide \n", "import mynat.add -- hide\n", "import game.Peano.level_3 -- hide\n", "namespace N -- hide\n", "a + 0 = a\n", "a + succ(b) = succ(a + b)\n", "Man kann die Addition zweier nat\u00fcrlichen Zahlen rekursiv anhand der Peano-Axiome \ndefinieren.\n- F\u00fcr $a \\in \\mathbb{N}$ sei $a+0=a$\n- F\u00fcr $a,d \\in \\mathbb{N}$ sei $a+$`succ`$(d) = $`succ`$(a+d)$\n\nNach dem Prinzip der Induktion ist dann die Addition f\u00fcr alle Paare von nat\u00fcrlichen\nZahlen definiert.\n\nDie beiden Aussagen, die die Addition definieren, sind in LEAN implementiert und \nhaben jeweils den Namen `add_zero` und `add_succ`. Auch diese Aussagen k\u00f6nnen mit\ndem Befehl `rw` verwendet werden. `rw add_zero,` wandelt die Aussage `b+zero` in `b`\num.\n", "Definition: <br>\n`def add : N \u2192 N \u2192 N` <br>\n`| m 0 := m` <br>\n`| m (succ n) := succ (add m n)` <br>\n\nDen beiden definierenden Eigenschaften wird ein Namen gegeben: <br>\n`lemma add_zero (m : N) : m + zero = m := rfl` <br>\n`lemma add_succ (m n : N) : m + succ n = succ (m + n) := rfl`\n", "Klicke hier, um die Definition der Addition der nat\u00fcrlichen Zahlen in LEAN zu sehen. Du musst diesen Code nicht zu 100% verstehen.", "In diesem Level werden wir eine Aussage beweisen, in der die Addition der\nnat\u00fcrlichen Zahlen vorkommt. Die Aussage ist: Sei $a \\in \\mathbb{N}$. \nDann ist `succ`$(a)+0=$`succ`$(a+0)$. Wir k\u00f6nnen diese Aussage beweisen,\nindem wir die Aussage `add_zero` mit `rw` auf den Beweiszustand anwenden.\n\nIn dieser Aussage kommen zwei Ausr\u00fccke der Form $n+0$ vor. Man kann bei der\nTactic rw konkretisieren, auf welche der beiden Stellen rw angewandt werden\nsoll. Probiere in dem Beweis erst `rw add_zero a,` aus. L\u00f6sche diese Zeile\nund schreibe stattdessen `rw add_zero a.succ,`. Siehts du den unterschied im\nBeweiszustand?\n", "Sei $a \\in \\mathbb{N}$. Dann ist `succ`$(a)+0=$`succ`$(a+0)$.\n", "end N -- hide", "Addition mit dem Nachfolger von 0", "import mynat.add -- hide\n", "import game.Addition.level_1 --hide\n", "namespace N -- hide\n", "In diesem Level werden wir zeigen, dass Addition mit dem Nachfolger von $0$ (den\nwir noch nicht formal als $1$ eingef\u00fchrt haben), gleich dem Nachfolger der Zahl ist.\nL\u00f6se den Beweis mit `rw` und den verf\u00fcgbaren Axiomen.\n", "Sei $a \\in \\mathbb{N}$. Dann ist $a+$`succ`$(0)=$`succ`$(a)$\n", "end N -- hide", "Die nat\u00fcrliche Zahl 1", "import mynat.add -- hide\n", "import game.Addition.level_2 --hide\n", "namespace N -- hide\n", "one = succ(zero)\n", "Aus praktischen Gr\u00fcnden m\u00f6chten wir nun dem Nachfolger von $0$ einen Namen\ngeben. Diese Zahl nennen wir $1$. Die Aussage `one = succ(zero)` hei\u00dft in\nLEAN `one_eq_succ_zero`.\n", "`def one : N := succ zero` <br>\n`theorem one_eq_succ_zero : one = succ zero := rfl`\n", "Klicke hier, um die Definition der Nummer $1$ in LEAN zu sehen. Du musst diesen Code nicht zu 100% verstehen.", "Nun k\u00f6nnen wir zeigen, dass der Nachfolger von $a$ gleich $a+1$ ist. L\u00f6se\nden Beweis mit `rw` und den verf\u00fcgbaren Axiomen `one_eq_succ_zero`,\n`add_succ` und `add_zero`. \n", "Sei $a \\in \\mathbb{N}$. Dann ist `succ`$(a) = a + 1$.\n", "end N -- hide", "Addition mit 0 - von links", "import mynat.add -- hide\n", "import game.Addition.level_3 --hide\n", "namespace N -- hide\n", "## Anleitung\nfalls `n : N` gegeben ist, dann startet `induction n with d hd`\neinen Induktionsbeweis \u00fcber `n` der zu beweisenden Aussage. `d` wird \nder Name der Variable im Induktionsschritt sein, und `hd` ist die Aussage\nder Induktionsvoraussetzung.\n## Beispiel\nBei folgendem Zustand:\n```\nn : N\n\u22a2 2 * n = n + n\n```\nwird `induction n with d hd` zwei neue Ziele \u00f6ffnen:\n```\n\u22a2 2 * 0 = 0 + 0\n```\nund\n```\nd : N,\nhd : 2 * d = d + d\n\u22a2 2 * succ d = succ d + succ d\n```\n## Bemerkung\nF\u00fcr LEAN soll der Induktionsanfang f\u00fcr `zero` gezeigt werden. Wir arbeiten\naber mit der Darstellung `0` der Zahl Null. Deswegen m\u00fcssen wir im Induktionsanfang\ndie Darstellung der Null mit `rw N_zero_eq_zero,` von `zero` zu `0` \u00e4ndern.\n", "Nach Definition der Addition gilt: $a+0=a$. Wir haben aber noch nicht bewiesen,\ndass die Addition kommutativ ist. Es ist also noch nicht bewiesen, dass auch\n$0+a=a$ gilt.\n\nDies werden wir \u00fcber Induktion zeigen. Dazu lernen wir die `induction` Tactic in\nLEAN. Um einen Induktionsbeweis zu starten, m\u00fcssen wir `induction a with d hd,`\nschreiben. Dabei ist das $a$ die Variable, \u00fcber die induziert werden soll, $d$\nwird der Name der Variable im Induktionsschritt sein, und `hd` ist die Aussage\nder Induktionsvoraussetzung.\n\nNachdem du den Befehl `induction a with d hd,` eingibst, wirst du in der rechten\nSpalte sehen, dass du zwei Beweisziele hast: den Induktionsanfang und die \nInduktionsvoraussetzung. Um den Beweis \u00fcbersichtlicher zu f\u00fchren, kannst du\ndie zwei Teile mit geschweiften Klammern umgeben. Dein Beweis hat dann die Form: <br>\n`begin` <br>\n  `induction a with d hd,` <br>\n  `{},` <br>\n  `{},` <br>\n`end` <br>\nInnerhalb der geschweiften Klammern kannst du dann jeweils den Induktionsanfang und\nden Induktionsschritt zeigen. Hinter die Klammern, wie auch hinter jedem Schritt in\nden Klammern geh\u00f6rt wie immer ein \",\".\n\nACHTUNG: F\u00fcr LEAN soll der Induktionsanfang f\u00fcr `zero` gezeigt werden. Wir arbeiten\naber mit der Darstellung `0` der Zahl Null. Deswegen m\u00fcssen wir im Induktionsanfang\ndie Darstellung der Null mit `rw N_zero_eq_zero,` von `zero` zu `0` \u00e4ndern.\n", "Sei $a \\in \\mathbb{N}$. Dann ist $0+a=a$.\n", "end N -- hide", "Assoziativit\u00e4t der Addition", "import mynat.add -- hide\n", "import game.Addition.level_4 --hide\n", "namespace N -- hide\n", "Nun werden wir die Assoziativit\u00e4t der Addition der nat\u00fcrlichen\nZahlen zeigen. Das bedeutet $(a + b) + c = a + (b + c)$. Dies ist wieder\n\u00fcber einen Induktionsbeweis m\u00f6glich. In diesem Level werden wir uns \neinen fertigen Beweis anschauen und dann mit der neuen Tactic \"repeat\" verk\u00fcrzen.\n\nAls erstes kannst du dazu folgenden Beweis als L\u00f6sung reikopieren und ihn\nSchritt f\u00fcr Schritt nachvollziehen.\n```\ninduction c with d hd,\n  {rw N_zero_eq_zero,\n  rw add_zero,\n  rw add_zero,},\n  {rw add_succ (a+b) d,\n  rw add_succ,\n  rw add_succ,\n  rw hd,},\n```\nWie du siehst muss man in diesem Beweis sowohl im Induktionsanfang wie im\nInduktionschritt den gleichen Beweisschritt mehrmals hintereinander ausf\u00fchren.\nDas kann man in LEAN mit der Tactic \"repeat\" verk\u00fcrzen, die einen gegebenen\nBeweisschritt so oft wiederholt, wie es m\u00f6glich ist. Bei dem Zustand:\n```\na : N, \n\u22a2 a + 0 + 0 + 0 = a\n```\nwird der Befehl `repeat{rw add_zero,},` dreimal den Befehl `add_zero` anwenden\nund somit den Beweiszustand zu `a=a` umformen und den Beweis schlie\u00dfen. Achte\nauf das Komma innehalb wie auch au\u00dferhalb der Klammer.\n\nVerwende nun `repeat` um den vorhandenen Beweis zu verk\u00fcrzen.\n", "Noch eine Bemerkung: LEAN ist linksassoziativ. Das bedeutet, dass f\u00fcr LEAN\n$a+b+b$ das gleiche wie $(a+b)+c$ ist.\n", "Seien $a, b, c \\in \\mathbb{N}$. Dann ist $(a + b) + c = a + (b + c)$.\n", "## Anleitung\nf\u00fcr einen Beweisschritt `step,`, f\u00fchrt `repeat {step,},` so oft den\nBeweisschritt aus wie es m\u00f6glich ist.\n## Beispiel\nBei folgendem Zustand:\n```\na : N, \n\u22a2 a + 0 + 0 + 0 = a\n```\nwird `repeat{rw add_zero,},` dreimal den Befehl `add_zero` anwenden\nund somit den Beweiszustand zu `a=a` umformen und den Beweis schlie\u00dfen.\n", "end N -- hide", "Addition mit dem Nachfolger - von links", "import mynat.add -- hide\n", "import game.Addition.level_5 --hide\n", "namespace N -- hide\n", "Genauso wie wir aus $a+0=a$ nicht direkt $0+a=a$ folgern k\u00f6nnten, k\u00f6nnen wir\naus $b + $`succ`$(a) =$ `succ`$(b+a)$ nicht `succ`$(a)+b =$ `succ`$(a+b)$\nfolgern. Wir haben n\u00e4mlich noch nicht bewiesen, dass die Addition kommutativ ist.\n\nAuch hier k\u00f6nnen wir einen Induktionsbeweis f\u00fchren. In diesem Level wirst du einen\nunvollst\u00e4ndigen Beweis vervollst\u00e4ndigen.\n\nKopiere dazu folgenden unvollst\u00e4ndigen Beweis in die Aufgabe:\n```\ninduction b with d hd,\n  {rw N_zero_eq_zero,\n  rw add_zero,\n  rw add_zero,},\n  {sorry,},\n```\nKlicke dich durch den Beweis und achte dabei auf den Beweiszustand und wie er sich\nmit den unterschiedlichen Beweisschritten \u00e4ndert. Zu erg\u00e4nzen ist der Induktionsschritt,\nder zurzeit noch durch `sorry,` platzhaltend \"gel\u00f6st\" ist. \n\nL\u00f6sche dieses `sorry,` und erg\u00e4nze den Induktionsschritt.\n", "Seien $a, b \\in \\mathbb{N}$. Dann ist `succ`$(a)+b = $`succ`$(a+b)$.\n", "Der Induktionschritt kann wiefolgt gef\u00fchrt werden:\n```\nrw add_succ,\nrw hd,\nrw add_succ,\n```\nKopiere diesen Code und versuche ihn Schritt f\u00fcr Schritt nachzuvollziehen.\n", "Kommst du mit dem Induktionsschritt nicht weiter?", "end N -- hide", "Kommutativit\u00e4t der Addition", "import mynat.add -- hide\n", "import game.Addition.level_6 --hide\n", "namespace N -- hide\n", "Endlich k\u00f6nnen wir zeigen, dass die Addition kommutativ ist!\n\nAuch hier k\u00f6nnen wir einen Induktionsbeweis f\u00fchren. In diesem Level wirst du einen\nfast richtigen Beweis korrigieren.\n\nKopiere dazu folgenden Beweis mit Fehler in die Aufgabe:\n```\ninduction b with d hd,\n{rw N_zero_eq_zero,\nrw add_zero a,\nrw zero_add a,},\n{rw add_succ a,\nrw hd,\nrw succ_add b,},\n```\nKlicke dich durch den Beweis und achte dabei auf den Beweiszustand und wie er sich\nmit den unterschiedlichen Beweisschritten \u00e4ndert. Zu korrigieren ist der Induktionsschritt. \n\nFinde den Fehler, indem du insbesondere auf die Fehlermeldung achtest. Kannst du den Beweis\nkorrigieren?\n", "Seien $a, b \\in \\mathbb{N}$. Dann ist a+b=b+a.\n", "Der Fehler `unknown identifier 'b'` deutet darauf hin, dass LEAN die Variable `b` in diesem\nKontext nicht kennt. Denk daran, dass im Induktionschritt bewiesen wird, dass falls die\nAussage f\u00fcr ein `d` (also a+d=d+a) gilt, die Aussage auch f\u00fcr `d.succ` \n(also a+d.succ = d.succ+a) gilt. Hier kommt also kein `b` mehr vor.\n", "Kommst du mit der Fehlersuche nicht weiter?", "end N -- hide", "Kommutativit\u00e4t der rechten Summanden", "import mynat.add -- hide\n", "import game.Addition.level_7 --hide\n", "namespace N -- hide\n", "Das Ziel dieses Levels ist f\u00fcr nat\u00fcrliche Zahlen $a,b,c$ $a+b+c=a+c+b$ zu zeigen.\nDas sieht vielleicht erstmal danach aus, dass du nur `add_comm,` anwenden muss. \nAber LEAN ist links-assoziativ. Das bedeutet, dass diese Aussage mit Klammern so \ngeschrieben werden kann: $(a+b)+c=(a+c)+b$. Um dieses Lemma zu zeigen, wirst du also \nauch die Assoziativit\u00e4t verwenden. Dieses Lemma wird dir in zuk\u00fcnftigen Beweisen etwas \nSchreibarbeit sparen.\n\nIn diesem Level werden dir die Beweischritte \"in normaler Sprache\" vorgegeben, die du\ndann in LEAN-Spache umsetzten kannst. Der Beweis besteht aus drei Schritten. Wir empfehlen\nbei jedem Schritt zu spezifizieren, auf welchen Teil sich rw beziehen soll.\n\n1. Wende die Assoziativit\u00e4t der Addition an, um in der linken Seite des Ausdrucks \numzuklammern.  Der Beweiszustand a + b + c = a + c + b soll zu a + (b + c) = a + c + b werden.\n2. Wende die Kommutativit\u00e4t der Addition an, um das b und c in der linken Seite des\nAusdrucks umzuklammern. Der Beweiszustand a + (b + c) = a + c + b soll zu \na + (c + b) = a + c + b werden.\n3. Wende die Assozitivit\u00e4t der Addition nun r\u00fcckwerts an, um in der linken Seite des\nAusdrucks umzuklammern. Der Beweiszustand a + (c + b) = a + c + b soll zu \na + c + b = a + c + b werden und somit den Beweis l\u00f6sen.\n", "Seien $a, b, c \\in \\mathbb{N}$. Dann ist $a+b+c=a+c+b$.\n", "end N -- hide", "Ein Existenzbeweis", "import data.nat.basic -- hide\n", "import tactic -- hide\n", "namespace nat -- hide\n", "Nun hast du alle grundlegenden Eigenschaften der Addition gezeigt. In den\nverbleibenden Levels der \"Addition\" m\u00f6chten wir nun ein bisschen \"rechnen\".\n\nIn diesem Level geht es konkret darum zu zeigen, dass es nat\u00fcrliche Zahlen\n$a$ und $b$ gibt, sodass a+b=10. Um das zu Beweisen muss man nur ein solches\nPaar an Zahlen angeben, zum Beispiel $4$ und $6$. In diesem Level werden wir\ndie Tactic `use` kennenlernen, mit der man bei Existenzaussagen im Beweiszustand\nkonkrete Objekte \u00fcbergeben kann. Wir f\u00fchren `use` am Beispiel dieses Levels ein:\nDer Zustand ist:\n```\n\u22a2 \u2203 (a b : \u2115), a + b = 10\n```\nMit `use [4,6],` wird der Beweiszustand ersetzt durch `\u22a2 4 + 6 = 10`, was den\nBeweis direkt l\u00f6st. \nProbier diesen Schritt direkt im Beweis aus. Du kannst $4$ und $6$ nun auch durch\nandere Zahlenpaare ersetzen, die $10$ ergeben. Probiere zuletzt noch aus, den\nSchritt einzuteilen in:\n```\nuse [4],\nuse [6],\n```\ndann kannst du im Zwischenschritt nachvollziehen, was `use` ver\u00e4ndert hat.\n", "/- F\u00fcr welches $a \\in \\mathbb{N}$ kann der Beweis mit `repeat{use a,},` gel\u00f6st werden?\nDas funktioniert nur mit $a=5$. In diesem Fall wird dann zweimal `use 5,` ausgef\u00fchrt,\nwas analog zu `use [5,5],` ist. Probier es doch mal aus!\n-/\n", "Es existieren $a, b, \\in \\mathbb{N}$, sodass a+b=10.\n", "## Anleitung\nf\u00fcr einen Beweiszustand `\u22a2 \u2203 (a : \u2115), Aussage(a)` setzt `use [b],` `b` ein,\nsodass der Beweiszustand zu `\u22a2 Aussage(b)` wird. `b` muss nicht eine konkrete\nZahl sein, sonder kann eine Variable sein, zum Beispiel eine Induktionsvariable.\nEs k\u00f6nnen mehrer Werte \u00fcbergeben werden (`[b,c]`), wenn die Existenzaussage mehrere\nVariablen enth\u00e4lt. \n## Beispiel\nBei folgendem Zustand:\n```\n\u22a2 \u2203 (a b : \u2115), a + b = 10\n```\nsetzt `use [4,6],` jeweils $4$ und $6$ f\u00fcr `a` und `b` ein und l\u00f6st den Beweis.\n", "end nat -- hide", "L\u00f6sung einer Linearen Gleichung", "-- namespace nat -- hide \n", "import data.nat.basic -- hide\n", "import tactic -- hide\n", "namespace nat -- hide\n", "In diesem Level wirst du Beweisen, dass $a=5$ die lineare Gleichung\n$a+3=8$ l\u00f6st. Dazu braucht man die Rechenregeln der Addition, die du\nja bereits bewiesen hast. Wir wollen diese aber nicht mehr Schritt \nf\u00fcr Schritt anwenden, sondern lineare Umformungen direkt LEAN \u00fcberlassen.\n\nDazu gibt es die Tactic `linarith`, die automatisch den Beweiszustand mithilfe\nder gegebenen Hypothesen und linearen arithmetischen Operationen vereinfacht.\nDu kannst diesen Beweis l\u00f6sen, indem du einfach `linarith,` schreibst.\n", "Wir w\u00fcrden folgende Umformungen an `h` machen:\na+3=8\na+succ(2)=8\nsucc(a+2)=8\nsucc(a+succ(1))=8\nsucc(succ(a+1))=8\nsucc(succ(a+succ(0)))=8\nsucc(succ(succ(a+0)))=8\nsucc(succ(succ(a)))=8\nsucc(succ(succ(a)))=succ(7)\nsucc(succ(succ(a)))=succ(succ(6))\nsucc(succ(succ(a)))=succ(succ(succ(5)))\na = 5\n", "Ohne `linarith` w\u00e4re der Beweis aufw\u00e4ndig.", "Sei $a \\in \\mathbb{N}$ mit $a+3=5$. Dann ist a=5.\n", "## Anleitung\nDie Taktik `linarith` in Lean f\u00fchrt lineare Arithmetik,\num automatisch Ungleichungen und Gleichungen in nat\u00fcrlichen Zahlen zu l\u00f6sen\n## Beispiel\nBei folgendem Zustand:\n```\na: \u2115\nh: a + 3 = 8\n\u22a2 a = 5\n```\nl\u00f6st `linarith,` durch arithmetische Umformunge den Beweis.\n", "end nat -- hide", "L\u00f6sung einer linearen Gleichung mit Zwischenschritt", "import data.nat.basic -- hide\n", "import tactic -- hide\n", "namespace nat -- hide\n", "Hier hast du eine weitere lineare Gleichung $a+2=4$. Als Beweisziel ist aber\nnicht der Wert von $a$ gesucht, sonder von $a+3$. Das schafft zwar `linarith`\nauch direkt (probier es gerne aus!), wir wollen aber die Gelegenheit nutzen\num zu erkl\u00e4ren, wie man sich in Beweisen Zwischenziele setzen kann.\n\nIn diesem Beweis k\u00f6nnte es zum Beispiel sinnvoll sein, die Hypothese `ha : a=2`\nzu beweisen und diese zu verwenden, `a` mit `rw ha,` in den Beweiszustand einzusetzen.\nUm sich eine Hypothese als Zwischenziel vorzunehmen verwendet man die Tactic `have`.\nDazu schreibt man:\n```\nhave ha : a = 2,\n{...},\n```\nMan f\u00fchrt die Hypothese ha ein, die im weiterem Verlauf verwendet werden kann. Dazu muss\nsie aber in den Klammern bewiesen werden.\n\nIn diesem Level k\u00f6nnte der Beweis dann so aussehen:\n```\nhave ha : a = 2,\n{sorry,}, -- Beweise ha, du kannst dazu linarith verwenden\nsorry,    -- Beweise nun mithilfe von ha den Beweiszustand\n```\nKopiere diesen Code und erg\u00e4nze die beiden sorry.\n", "Sei $a \\in \\mathbb{N}$ mit $a+2=4$. Dann ist $a + 3=5$.\n", "## Anleitung\nDie Taktik have in Lean erlaubt es, einen Zwischenschritt w\u00e4hrend eines Beweises \nzu definieren, welches bewiesen werden soll um im restlichem Beweis verwendet\nzu werden.\n## Beispiel\nBei folgendem Zustand:\n```\na: \u2115\nh: a + 2 = 4\n\u22a2 a + 3 = 5\n```\nwird \n```\nhave ha : a = 2,\n{...},\n```\ndas Ziel ha einf\u00fchren, welches in den Klammern bewiesen werden soll und dann\nim Verlauf des Beweises verwendet werden darf.\n", "end nat -- hide", "Lineares Gleichungssystem", "-- namespace nat -- hide \n", "import data.nat.basic -- hide\n", "import tactic -- hide\n", "import mynat.one_eq -- hide\n", "namespace nat -- hide\n", "Wir schauen uns nun ein lineares Gleichungssystem an. Gegeben ist:\n```\na + b = 8\nb = 3\n```\nUnd zu zeigen ist, dass `a=5`. Auch hier k\u00f6nnte man direkt `linarith` anwenden\nund w\u00e4re fertig. Wir wollen uns aber die Frage stellen, wie wir eine hypothese\nwie `h`, die ein \"und\" (`\u2227`) enth\u00e4lt in zwei hypothesen einteilen kann, damit man\nsie einzeln verwenden kann.\n\nDazu gibt es die Tactic `cases`. F\u00fcr eine hypothese `h : h1 \u2227 h2` teilt `cases h with f g,`\ndie hypothese auf, sodass man die hypothesen `f : h1` und `g : h2` erh\u00e4lt. Die Namen der\nneuen Hypothesen k\u00f6nnen wir hier (`f g`) explizit angegeben werden oder werden ansonsten\nvon LEAN vergeben.\n\nWir werden in diesem Level so vorgehen, dass wir die hypothese aufteilen um `b=3` in \n`a+b=8` einzusetzten. Daf\u00fcr kannst du folgenden Schritte in deinem Beweis machen:\n1. Teile `h` auf. Du kannst die neuen hypothesen `hab` und `ha` nennen, um anzudeuten,\ndass `hab` die Gleichung ist die sowohl `a` wie auch `b` enth\u00e4lt und `ha` nur `a`.\n2. Setzte mithilfe von `rw` die Gleichung `hb` in `hab` ein.\n3. Nutze `linarith` um mit Umformungen den Beweis zu beenden.\n", "Seien $a, b \\in \\mathbb{N}$ mit $a+b=8$ und $b=3$. Dann ist $a=5$.\n", "## Anleitung\nF\u00fcr eine hypothese `h : h1 \u2227 h2` teilt `cases h with f g,`\ndie hypothese auf, sodass man die hypothesen `f : h1` und `g : h2` erh\u00e4lt.\n## Beispiel\nBei folgendem Zustand:\n```\nab: \u2115\nh: a + b = 8 \u2227 b = 3\n\u22a2 a = 5\n```\nf\u00fchrt `cases h with hab hb,` zu:\n```\nab: \u2115\nhab: a + b = 8\nhb: b = 3\n\u22a2 a = 5\n```\n.\n", "end nat -- hide", "Lineares Gleichungssystem - Teil 2", "-- namespace nat -- hide \n", "import data.nat.basic -- hide\n", "import tactic -- hide\n", "namespace nat -- hide\n", "In diesem Level m\u00f6chten wir ein letztes Gleichungssystem einf\u00fchren.\n```\na+b+3=8\na=b+1\n```\nEs soll gezeigt werden, dass die L\u00f6sung\n```\na=3\nb=2\n```\nist. In diesem Fall k\u00f6nnen wir nicht linarith direkt anwenden, weil in\nunserem Beweisziel ein \"und\" (`\u2227`) ist. Man kann aber ein Ziel, welches\nein \"und\" (`\u2227`) enth\u00e4lt mit der Tactic `split` in zwei Unterziele einteilen.\nIn unserem Fall wird mit `split,` das Ziel `a=3 \u2227 b=2` zu den Zielen\n`a=3` und `b=2`. Wie beim Induktionsbeweis kannst du die beiden Ziele\nin getrennten Umgebungen mit Klammern {} einteilen. Das Ger\u00fcst f\u00fcr diesen\nBeweis ist also \n```\nsplit,\n{sorry,},\n{sorry,},\n```\nKopiere dieses Ger\u00fcst, schau dir an was der erste Schritt bewirkt und\nersetze dann die beiden `sorry` mit Beweisen.\n", "Seien $a, b \\in \\mathbb{N}$ mit $a+b+3=8$ und $a=b+1$. Dann ist $a=3$ und $b=2$.\n", "/- Du wei\u00dft nicht wie du die Beweise an der Stelle der `sorry` f\u00fchren sollst?\nJetzt wo die Ziele jeweils nur einzelne Gleichungen sind kannst du `linarith` verwenden.\n-/\n", "## Anleitung\nMan kann aber ein Ziel, welches\nein \"und\" (`\u2227`) enth\u00e4lt mit der Tactic `split` in zwei Unterziele einteilen.\n## Beispiel\nFolgendem Zustand:\n```\nab: \u2115\nh: a + b + 3 = 8 \u2227 a = b + 1\n\u22a2 a = 3 \u2227 b = 2\n```\nwird durch `split,` zu:\n```\nab: \u2115\nh: a + b + 3 = 8 \u2227 a = b + 1\n\u22a2 a = 3\nab: \u2115\nh: a + b + 3 = 8 \u2227 a = b + 1\n\u22a2 b = 2\n```\n", "end nat -- hide", "Multiplikation", "Die Multiplikation", "import mynat.mul -- hide\n", "import game.Addition.level_8 --hide\n", "namespace N -- hide\n", "a * 0 = 0\n", "a * succ(b) = a*d+a\n", "Man kann auch die Multiplikation zweier nat\u00fcrlichen Zahlen rekursiv anhand der \nPeano-Axiome definieren.\n- F\u00fcr $a \\in \\mathbb{N}$ sei $a*0=0$\n- F\u00fcr $a,d \\in \\mathbb{N}$ sei $a* $`succ`$(d) = a*d+a$\n\nNach dem Prinzip der Induktion ist dann die Multiplikation f\u00fcr alle Paare von\nnat\u00fcrlichen Zahlen definiert.\n\nDie beiden Aussagen, die die Multiplikation definieren, sind in LEAN implementiert und \nhaben jeweils den Namen `mul_zero` und `mul_succ`.\n", "Definition: <br>\n`def mul : N \u2192 N \u2192 N` <br>\n`| a zero := zero` <br>\n`| a (succ d) := mul a d + a` <br>\n\nDen beiden definierenden Eigenschaften wird ein Namen gegeben: <br>\n`lemma mul_zero (a : N) : a * zero = zero := rfl` <br>\n`lemma mul_succ (a d : N) : a * (succ d) = a * d + a := rfl`\n", "Klicke hier, um die Definition der Multiplikation der nat\u00fcrlichen Zahlen in LEAN zu sehen. Du musst diesen Code nicht zu 100% verstehen.", "Wir werden in den n\u00e4chsten Levels wieder grundlegende Rechenregeln beweisen. Dazu werden\nwir wieder ohne `linarith` arbeiten.\nIn diesem Level werden wir zeigen, dass auch die Multiplikation mit $0$ von links $0$ ergibt.\nWir haben die Kommutativit\u00e4t der Multiplikation noch nicht gezeigt. Da die Definition\nder Multiplikation sehr \u00e4hnlich zu der der Addition ist, wird auch dieser Beweis sehr \u00e4hnlich\nzu dem Beweis $0+a=0$ (Addition - Level 4) sein, du kannst diesen als Fahrplan verwenden:\n```\ninduction a with d hd,\n{rw N_zero_eq_zero,\nrw add_zero,},\n{rw add_succ,\nrw hd,},\n```\n", "Sei $a \\in \\mathbb{N}$. Dann ist $0*a=0$.\n", "end N -- hide", "Multiplikation mit dem Nachfolger - von links", "import mynat.mul -- hide\n", "import game.Multiplikation.level_1 --hide\n", "namespace N -- hide\n", "In diesem Level werden wir zeigen, dass $(a+1)*b=a*b+b$, ist, oder mit `succ`\nausgedr\u00fcckt: `succ(a) * b = a * b + b`. Du kannst diesen Beweis wieder \u00fcber\nInduktion l\u00f6sen.\n", "Bei `a` als Induktionsvariable h\u00e4ttest du im Induktionsschritt `succ(succ(a))*b=succ(a)*b+b`.\nHier wird es schwer sein so umzuformen, dass man die Induktionsvoraussetzung verwenden kann,\nweil wir bis jetzt nur `mul_succ` verwenden k\u00f6nnen, welches angewandt werden kann\nwenn im zweiten Faktor `succ` vorkommt. Daf\u00fcr eignet sich `b` als Induktionsvariable,\nweil genau dann beim Induktionsschritt `succ` im zweiten Faktor vorkommt.\n", "Ist die Induktion \u00fcber `a` oder \u00fcber `b` geschickter?", "Du kannst mit diesem Beweisger\u00fcst starten. Zu erg\u00e4nzen ist:\n1. Die Induktionsvariable\n2. Der Induktionsanfang\n3. Die Umformungen zu Beginn des Induktionsschrittes, die gemacht werden m\u00fcssen damit\ndie Induktionsvorraussetzung `hd` verwendet werden kann.\n\n```\ninduction Induktionsvariable with d hd,\n{rw N_zero_eq_zero,\nsorry,},\n{sorry,\nrw hd,\nrepeat {rw add_succ,},\nrw add_right_comm,\n},\n```\n", "Seien $a, b \\in \\mathbb{N}$. Dann ist `succ`$(a) * b = a * b + b$.\n", "end N -- hide", "Kommutativit\u00e4t der Multiplikation", "import mynat.mul -- hide\n", "import game.Multiplikation.level_2 -- hide\n", "namespace N -- hide\n", "Die Ergebnisse aus Level 1 und 2 sind genug, um die Kommutativit\u00e4t der Multiplikation\nzu zeigen! Hier ist zur Erinnerung der Beweis der Kommutativit\u00e4t der Addition:\n```\ninduction b with d hd,\n{rw N_zero_eq_zero,\nrw add_zero a,\nrw zero_add a,},\n{rw add_succ a,\nrw hd,\nrw succ_add d,},\n```\n", "Vielleicht ist dir aufgefallen, dass man in dem Beweis aus der Addition nur\n\u00fcberall `add` mit `mul` ersetzten musste. Wie sieht in normaler mathematischen \nSprache aus? Formuliere dazu die Beweise add_comm und mul_comm schriftlich aus.\n", "Aufgabe nach dem L\u00f6sen des Lean-Beweises", "Seien $a, b \\in \\mathbb{N}$. Dann ist a * b = b * a\n", "end N -- hide", "Das Distributivgesetz", "import mynat.mul -- hide\n", "import game.Multiplikation.level_3 -- hide\n", "namespace N -- hide\n", "Das Distributivgesetz gibt uns an, wie wir mit Ausdr\u00fccken umgehen k\u00f6nnen, in denen\nAddition und Multiplikation vorkommen. Wir werden hier die \"Linksdistributivit\u00e4t\"\nzeigen, also $c*(a+b)=c*a+c*b$, daraus folgt aber nicht direkt $(a+b)*c=a*c+b*c$.\n\nIn diesem Level startest du den Beweis selber. Denk daran, dass bei Indukzion\noft der Schritt `rw N_zero_eq_zero,` n\u00f6tig ist. Wenn du nicht weiterkommst sind\nunter der Aufgabe Hinweise.\n", "Seien $a, b, c \\in \\mathbb{N}$. Dann ist $c * (a + b) = c * a + c * b$.\n", "```\ninduction Induktionsvariable with d hd,\n{rw N_zero_eq_zero,\nsorry,},\n{sorry,},\n```\n", "Hinweis: Beweisstruktur", "Verwende `b` als Induktionsvariable.\n", "Induktionsvariable", "Du ben\u00f6tigst in diesem Beweis nur die `induction` und `rw` tactics. `rw` wendest du\nauf die Induktionshypothese und folgende S\u00e4tze an: `N_zero_eq_zero`, `add_zero`, `mul_zero`,\n`add_succ`, `mul_succ`, `add_assoc`. \n", "Hinweis: Ben\u00f6tigte Tactics und S\u00e4tze", "end N -- hide", "Assoziativit\u00e4t der Multiplikation", "import mynat.mul -- hide\n", "import game.Multiplikation.level_4 -- hide\n", "namespace N -- hide\n", "Zuletzt Beweisen wir die Assoziativit\u00e4t der Multiplikation. Schau dir dazu zun\u00e4chst\nwieder den Beweis der Assoziativit\u00e4t der Addition an:\n```\ninduction c with d hd,\n{rw N_zero_eq_zero,\nrepeat{rw add_zero,},},\n{repeat{rw add_succ,},\nrw hd,},\n```\n", "Nein, f\u00fcr diesen Beweis brauchst du n\u00e4mlich das Distributivgesetz. Das kommt daher, dass die \nDefinition der Multiplikation von der Addition abh\u00e4ngt (`a*succ(d)=a*d+a`).\n", "Kannst du auch bei der Assoziativit\u00e4t den Beweis aus der Addition einfach \u00fcbernehmen?", "Seien $a, b, c \\in \\mathbb{N}$. Dann ist $(a * b) * c = a * (b * c)$.\n", "end N -- hide", "Multiplikation mit einer geraden Zahl ergibt eine gerade Zahl", "-- namespace nat -- hide \n", "import data.nat.basic -- hide\n", "import tactic -- hide\n", "namespace nat -- hide\n", "Nun haben wir alle grundlegenden Eigenschaften der Addition und Multiplikation gezeigt.\nDu darfst also insbesondere `linarith` wieder verwenden. \n\nIn diesem Level werden wir zeigen, dass die Multiplikation mit einer geraden Zahl\neine gerade Zahl ergibt. Also: Seien $a, b$ nat\u00fcrliche Zahlen. Falls es eine nat\u00fcrliche\nZahl $c$ gibt, sodass $a=2*c$ ,\ndann gibt es eine mat\u00fcrliche Zahl $d$, sodass $a*b=2*d$.\n\nDa die Existenz von dem $d$ gezeigt wird, wirst du wieder die Tactic `use` brauchen,\ndie wir bereits in anderen Existenzbeweisen gesehen haben. Nun hast du aber auch\neine Existenzaussage in den Voraussetzungen. Du wirst in deinem Beweis das konkrete\n$c$ f\u00fcr das $a=2*c$ gilt brauchen. Dazu kannst du die Tactic `obatin` verwenden. Diese\nverwendet die Existenzaussage um eine Variable $c$ einzuf\u00fchren und die Aussage, dass\nf\u00fcr dieses c $a=2*c$ gilt. Konkret:\n\nF\u00fcr die Aussage `(hger : \u2203 c : \u2115, a=2*c)`, wird `obtain \u27e8c, ager\u27e9 := hger,` folgendendes\nim Zustand erg\u00e4nzen:\n```\nc : N\nager : a=2*c\n```\nDabei sind die Argumente in den Klammern die Namen, die jeweil die Variable und die\nAussage bekommen sollen und das Argument nach dem `:=` die Existenzaussage.\n\nDu kannst den folgenden Beweis mit dieser Zeile starten.\n", "Seien $a, b \\in \\mathbb{N}$. Falls es ein $c \\in \\mathbb{N}$ gibt, sodass $a=2*c$ ,\ndann gibt es ein $d \\in \\mathbb{N}$, sodass $a*b=2*d$.\n", "## Anleitung\nObtain (`obtain \u27e8c, hc\u27e9 := h,`) verwendet die Existenzaussage `h : \u2203 c : \u2115, hc` um eine \nVariable `c` und die entsprechende Aussage `hc` (h im konkretem Fall von `c`) einzuf\u00fchren.\n## Beispiel\nBei folgendem Zustand:\n```\na b: \u2115\nhger: \u2203 (c : \u2115), a = 2 * c\n\u22a2 \u2203 (d : \u2115), a * b = 2 * d\n```\nf\u00fchrt `obtain \u27e8c, ager\u27e9 := hger,` zu:\n```\na b c: \u2115\nager: a = 2 * c\n\u22a2 \u2203 (d : \u2115), a * b = 2 * d\n```\n", "end nat -- hide", "Ungleichungen", "Ungleichungen", "import data.nat.basic -- hide\n", "import tactic -- hide\n", "namespace nat -- hide \n", "Nun werden wir uns mit Ungleichungen auseinandersetzen. Dazu wird als erstes $\u2264$\ndefiniert. Und zwar ist f\u00fcr nat\u00fcrliche Zahlen $a$ und $b$ $a\u2264b$ genau dann, wenn es\neine nat\u00fcrliche Zahl $c$ gibt, sodass $b=a+c$. Dieser Zusammenhang ist in Lean\nunter dem Satz `le_iff_exists_add` (`le` steht f\u00fcr \"less or equal\") gespeichert:\n\n`le_iff_exists_add (a b : \u2115) : a \u2264 b \u2194 \u2203 (c : \u2115), b = a + c`.\n\nDu kannst diesen Satz mit `rw` verwenden. Oft ist es aber sehr aufw\u00e4ndig eine\nUngleichung \u00fcber die Existenz eines `c` zu zeigen. Deswegen f\u00fchren wir hier die\nTactic `simp` ein. `simp` verwendet Gleichungen und Ungleichungen im Beweiszustand \num den Beweis zu vereinfachen oder zu beenden. Insbesondere kann `simp` ein\nBeweisziel wie `2\u22646` l\u00f6sen.\n\nIn diesem Level ist zu zeigen, dass es eine nat\u00fcrliche Zahl kleiner gleich $2$\ngibt. Beginne den Beweis, und sobal du ein Beweisziel der Form `a\u2264b` hast, verwende\n`simp`.\n", "```\nuse 1, -- Dieses use bezieht sich auf a\nrw le_iff_exists_add,\nuse [1], -- Dieses use bezieht such auf c\n```\n", "Nach dem du den Beweis gel\u00f6st hast: wie w\u00e4re der Beweis ohne `simp`?", "Es gibt ein $a \\in \\mathbb{N}$ mit $a\\leq2$.\n", "## Anleitung\n`simp` verwendet Gleichungen und Ungleichungen im Beweiszustand um den Beweis zu vereinfachen\noder zu beenden. Es kann entweder eine konkrete Aussage `h` \u00fcbergeben werden, die vereinfacht\nwerden soll (`simp [h],`) oder einfach `simp,` verwendet werden.\n## Beispiel\nBei folgendem Zustand:\n```\n\u22a2 1 < 2\n```\nl\u00f6st `simp,` den Beweis.\n", "end nat -- hide", "Pythagoreisches Tripel", "-- namespace nat -- hide \n", "import data.nat.basic -- hide\n", "import tactic -- hide\n", "namespace nat -- hide \n", "Ein pythagoreisches Tripel besteht aus drei positiven nat\u00fcrlichen Zahlen $a$, $b$\nund $c$, die die Gleichung $a^2 + b^2 = c^2$ erf\u00fcllen. Diese Tripel sind besonders\nbekannt im Zusammenhang mit dem Satz des Pythagoras, der besagt, dass in einem \nrechtwinkligen Dreieck das Quadrat der Hypotenuse $c$ gleich der Summe der Quadrate\nder beiden Katheten $a$ und $b$ ist.\n\nIn diesem Level m\u00f6chten wir zeigen, dass ein solches Tripel existiert. Da wir keine\nPotenzen eingef\u00fchrt haben schreiben wir $a^2$ als $a*a$.\n", "Es gibt $a, b, c \\in \\mathbb{N}$ mit $a*a+b*b+c*c$.\n", "Bei Existenzbeweisen brauchst du die Tactic `use`. Denk auch daran, dass du die Tactic\n`linarith` verwenden darfst um Ausdr\u00fccke zu vereinfachen.\n", "Kommst du nicht weiter?", "end nat -- hide", "Gerade Quadratzahl", "import data.nat.basic -- hide\n", "import tactic -- hide\n", "namespace nat -- hide \n", "In diesem Level m\u00f6chten wir zeigen, dass es eine gerade Quadratzahl gibt. Eine\nnat\u00fcrliche Zahl $a$ hei\u00df Quadratzahl, genau dann wenn es eine nat\u00fcrliche Zahl\n$b$ gibt, sodass $a=b^2$. In diesem Level werden wir das als `a=c*c` schreiben.\n", "Es gibt $a, b, c \\in \\mathbb{N}$ mit $a=2*b$ und $a=c*c$.\n", "/- Wie war das nochmal mit Beweiszielen die `\u2227` beinhalten?\nSchau dir dazu die Tactic `split` an.\n-/\n", "end nat -- hide", "Aussagen negieren", "import data.nat.basic -- hide\n", "import tactic -- hide\n", "namespace nat -- hide \n", "In diesem Level werden wir lernen, wie wir ein Beweisziel, welches mit einem\nNegationszeichen anf\u00e4ngt weiter vereinfachen. In deisem Level zum Beispiel ist\ndas Beweisziel `\u00ac a > 4`. Wir wissen, dass das equivalent zu `a \u2264 4` ist. Damit\nLean diese Umformung macht verwenden wir die Tactic `push_neg,`. Probier es zu\nBeginn dieses Beweises aus.\n", "Sei $a \\in \\mathbb{N}$ mit $a\\leq4$. Dann gilt nicht, dass $a>4$.\n", "/- Wie schlie\u00df ich nochmal ein Beweisziel das gleich zu einer der gegebenen Aussagen ist?\nSchau dir dazu die Tactic `exact` an.\n-/\n", "## Anleitung\n`push_neg` vereinfacht ein Beweisziel, welches mit einem Negationszeichen anf\u00e4ngt.\n## Beispiel\nWenn `push_neg` angewandt wird, wird:\n```\n\u22a2 \u00aca > 4\n```\nzu:\n```\n\u22a2 a \u2264 4\n```\n", "end nat -- hide", "Der Widerspruchsbeweis", "-- namespace nat -- hide \n", "import data.nat.basic -- hide\n", "import tactic\n", "namespace nat -- hide \n", "In LEAN wird f\u00fcr einen Widerspruchsbeweis die Tactic `by_contra` verwendet.\nAngenommen, du m\u00f6chtest die Aussage P mit einem Widerspruchsbeweis beweisen, \nDu verwendest als erstes `by_contra` um den Widerspruchsbeweis zu starten.\nDu wirst sehen, dass nun `\u00acP` unter den gegebenen Aussagen ist, und das neue\nBeweisziel `\u22a2 false` ist. Das bedeutet, dass das Ziel ist, einen Widespruch zu\nerzeugen.\n\nEin Widerspruchsbeweis sieht also zum Beispiel so aus:\n\n```\ntheorem no_n_succ_eq_zero : \u00ac\u2203 (n : \u2115), n+1=0 :=\nbegin\nby_contra hex,\nobtain \u27e8n, hn\u27e9 := hex,\nlinarith,\nend\n```\nDabei kann man nach `by_contra` einen Namen (hier `hex`) f\u00fcr die Widerspruchsannahme geben.\n\nIn diesem Level werden wir mit einem Widerspruchsbeweis zeigen, dass es keine nat\u00fcrliche\nZahl $a<4$ gibt, die ein echtes Vielfaches von $4$ ist.\n\nUm den Lean beweis zu schreiben, kannst du diesen Beweis verwenden:\n1. Widerspruchsannahme: Angenommen es gibt $a, b \\in \\mathbb{N}$ mit $b>0$, $a<4$ und $a=b*4$.\n2. Seien nun $a, b \\in \\mathbb{N}$ sodass $b>0$, $a<4$ und $a=b*4$.\n3. Wir geben der Aussage $b>0$ den Namen hb, der Aussage $a<4$ den Namen ha und der Aussage\n$a=b*4$ den Namen hab.\n4. Wir zeigen nun zuerst, dass $a\\geq0$, indem wir die Aussage hnm und arithmetische\nOperationen verwenden.\n5. Mit dieser neuen Aussage und arithmentischen Operationen l\u00e4sst sich ein Widerspruch\nzur Aussage hn herleiten.\n", "Es gibt kein $a, b \\in \\mathbb{N}$ mit $b>0$, $a<4$ und $a=b*4$.\n", "## Anleitung\nWenn eine Aussage `P` zu beweisen ist, startet `by_contra` einen Widerspruchsbeweis\nindem `\u00acP` zu den gegebenen Aussagen hinzugef\u00fcgt wird und das Beweisziel zu `\u22a2 false` wird.\n## Beispiel\nFolgender Zustand:\n```\n\u22a2 \u00ac\u2203 (n : \u2115), n + 1 = 0\n```\nwird durch `by_contra hex,` zu \n```\nhex: \u2203 (n : \u2115), n + 1 = 0\n\u22a2 false\n```\n", "end nat -- hide", "Division mit Rest", "Existenz Divisor und Rest - unbeschr\u00e4nktes $r$", "import data.nat.basic -- hide\n", "import tactic -- hide\n", "namespace nat -- hide\n", "Wir m\u00f6chten zuletzt noch zeigen, dass die Division mit Rest \u00fcber den nat\u00fcrlichen\nZahlen funktioniert. Das hei\u00dft, dass es f\u00fcr nat\u00fcrliche Zahlen $n, m$ mit $m>0$ gilt: \nEs gibt nat\u00fcrliche Zahlen $q, r$ mit $n = m*q + r$ und $r < m$.\n\nIn diesem Level werden wir zuerst eine abgeschw\u00e4chte Version zeigen, in der wir\nnicht fordern, dass $r < m$ ist. \n\nDazu werden wir lernen, wir mann in einem Beweis eine Fallunterscheidung macht. Wenn\nman in LEAN `by_cases h: a>4,` verwendet, dann teilt LEAN den Beweiszustand in zwei\nTeile. In beiden ist das Beweisziel das gleiche, in einem haben wir jedoch die\nAussage `h : a>4` und in dem anderen die Aussage `h : \u00ac a>4`. Wie bei anderen Tactics\ndie den Beweis aufteilen kannst du auch hier Klammern verwenden und somit folgende\nStruktur verwenden:\n```\nby_cases h: a>4,\n{},\n{},\n```\n\nVerwende f\u00fcr den Beweis in diesem Level folgendes Beweisger\u00fcst und erg\u00e4nze den\nInduktionsanfang, und die Beweise f\u00fcr die beiden F\u00e4lle, je nachdem ob d.succ ein\nVielfaches von m ist oder nicht:\n```\ninduction n with d hd,\n{ sorry, },\n{ by_cases hq : \u2203 q, d.succ = m*q,\n  { sorry, },\n  { sorry, }\n```\n", "Seien $n,m \u2208 \\mathbb{N}$ mit $m>0$. Dann gilt: Es gibt $q,r\\in \\mathbb{N}$ mit $n = m*q + r$.\n", "## Anleitung\n`by_cases h : ha,` startet eine Fallunterscheidung. In einem Fall gilt `h : ha` und im\nanderen gilt `h : \u00acha`. In beiden muss das urspr\u00fcngliche Beweisziel gezeigt werden.\n## Beispiel\nWenn\nman in LEAN `by_cases h: a>4,` verwendet, dann teilt LEAN den Beweiszustand in zwei\nTeile. In beiden ist das Beweisziel das gleiche, in einem haben wir jedoch die\nAussage `h : a>4` und in dem anderen die Aussage `h : \u00ac a>4`. Wie bei anderen Tactics\ndie den Beweis aufteilen kannst du auch hier Klammern verwenden und somit folgende\nStruktur verwenden:\n```\nby_cases h: a>4,\n{},\n{},\n```\n", "end nat -- hide", "Existenz Divisor und Rest", "-- namespace nat -- hide \n", "import data.nat.basic -- hide\n", "import tactic -- hide\n", "import game.Division_mit_Rest.level_1 --hide\n", "namespace nat -- hide \n", "Bevor wir uns unserem finalem Level widmen, indem wir die Aussage der\nDivision mit Rest f\u00fcr $r < m$ zeigen, brauchen wir noch ein Lemma, das wir\nhier auslagern, damit der Beweis im n\u00e4chsten Level nicht so kompliziert\nwird. \n\nDas Lemma wird dazu nutzen, im Induktionsschritt des Beweises der Division\nmir Rest zu zeigen, dass $r < m$. Aus der Induktionsvoraussetzung haben wir:\n```\nhr : r < m\nhq : d = m*q+r\n```\nAu\u00dferdem wird dieses Lemma in einer Fallunterscheidung verwendet, in dem Fall\ndas `d.succ` kein Vielfaches von `m` ist, also:\n```\nhq' : \u00ac \u2203 (q':\u2115), d.succ=m*q'\n```\n\nIn diesem Level musst du den Beweus nicht selber machen aber solltest ihn lesen\nund nachvollziehen. Dazu kannst du den Beweis direkt in das Feld kopieren:\n```\n/- zuerst zeigen wir, dass r+1 \u2264 m (da r < m) -/\n  have hr_succ_le_m : r + 1 \u2264 m,\n  { exact succ_le_of_lt hr, },\n  /- nun f\u00fchren wir einen Widerspruchbeweis. Wenn wir n\u00e4mlich annehmen,\n  dass r+1 \u2265 m, dann k\u00f6nnen wir danach mir hr_succ_le_m Gleichheit folgern -/ \n  by_contra h_contr,\n  push_neg at h_contr,\n  /- nun folgern wir r+1=m -/\n  have hr1_m : r+1=m,\n  {exact le_antisymm hr_succ_le_m h_contr,}, \n  /- damit k\u00f6nnen wir zeigen, dass d+1=m*(q+1) ist -/\n  have d_mult_q : d.succ = m*(q+1),\n  {rw succ_eq_add_one,\n  linarith,\n  },\n  /- Um nun einen Widerspruch herzustellen m\u00fcssen wir dies noch\n  als Existenzaussage formulieren. -/\n  have h_eq : \u2203 (q : \u2115), d.succ = m * q := \u27e8q+1, d_mult_q\u27e9,\n  /- Wir haven nun zwei widerspr\u00fcchliche Aussagen im Beweiszustand.\n  Mit contradiction kann der Widerspruchsbeweis beender werden. -/\n  contradiction,\n```\nDie Kommentare f\u00fchren dich durch den Beweis. Es werden zwei S\u00e4tze verwendet,\ndie du nicht kennst. Hier ist ihre Bedeutung:\n`succ_le_of_lt {a b : \u2115} (h : a < b) : succ a \u2264 b` \n`le_antisymm : \u2200 {a b : \u2115}, (a \u2264 b \u2227 b \u2264 a) \u2192 a = b`\n", "Seien $m,d,q,r \u2208 \\mathbb{N}$ mit $r < m$ und $d=m*q+r$. Falls es kein $q' \u2208 \\mathbb{N}$ gibt\nsodass $d+1=m*q$, dann gilt, dass $r+1 < m$\n", "end nat -- hide", "Existenz Divisor und Rest", "-- namespace nat -- hide \n", "import data.nat.basic -- hide\n", "import tactic -- hide\n", "import game.Division_mit_Rest.level_2 --hide\n", "namespace nat -- hide \n", "Nun k\u00f6nnen wir den Satz zum Beweis mit Rest zeigen. Dazu fehlt dir nur noch eine\nTactic, um das Lemma aus dem vorherigem Level anwenden zu k\u00f6nnen. Wenn die Voraussetzungen\neines anderen Satz in dem Beweiszustand gegeben sind und das Beweisziel das Ergebnis\ndieses Satzes ist, kann mit `apply Satz Voraussetzungen,` das Ziel gel\u00f6st werden.\n\nWenn man zum Beispiel der Satz:\n```\ntheorem mul_gerade (a b : \u2115) (hger : \u2203 c : \u2115, a=2*c) : \u2203 d : \u2115, a*b = 2*d\n```\nbereits bewiesen wurde und der Beweiszustand:\n```\nc d : \u2115\nhc: \u2203 (e : \u2115), c = 2 * e\n\u22a2 \u2203 (f : \u2115), c * d = 2 * f\n```\nist kann man `apply mul_gerade c d hc,` angewandt werden um den Beweis\nzu l\u00f6sen. Wichtig ist die Reihenfolge der Voraussetzungen, diese d\u00fcrfen\naber nat\u00fcrlich im neuen Kontext einen anderen Namen haben.\n\nIn diesem Level kannst du dich an der Struktur des vereinfachten Beweises orientieren:\n```\ntheorem exist_divisor_rest_gr (n m : \u2115) (hm : m > 0) : \u2203 q r : \u2115, n = m * q + r :=\nbegin\n  induction n with d hd,\n  { use [0, 0],\n    simp [hm], },\n  { by_cases hq' : \u2203 q', d.succ = m*q',\n    { obtain \u27e8q', hq'\u27e9 := hq',\n      use [q', 0],\n      simp [hq'],},\n    { use [0, d.succ],\n      simp, } }\nend\n\nmit dem Unterschied, dass du nach dem `use` Befehl nun eine Aussage mit `\u2227` zeigen\nmusst und hier also `split` verwenden solltest.\n```\n", "Seien $n,m \u2208 \\mathbb{N}$ mit $m>0$. Dann gilt: Es gibt $q,r\\in \\mathbb{N}$ mit $n = m*q + r$ und $r < m$.\n", "## Anleitung\nWenn die Voraussetzungen eines anderen Satz in dem Beweiszustand\ngegeben sind und das Beweisziel das Ergebnis dieses Satzes ist, kann\nmit `apply Satz Voraussetzungen,` das Ziel gel\u00f6st werden.\n## Beispiel\nWenn man zum Beispiel der Satz:\n```\ntheorem mul_gerade (a b : \u2115) (hger : \u2203 c : \u2115, a=2*c) : \u2203 d : \u2115, a*b = 2*d\n```\nbereits bewiesen wurde und der Beweiszustand:\n```\nc d : \u2115\nhc: \u2203 (e : \u2115), c = 2 * e\n\u22a2 \u2203 (f : \u2115), c * d = 2 * f\n```\nist kann man `apply mul_gerade c d hc,` angewandt werden um den Beweis\nzu l\u00f6sen. Wichtig ist die Reihenfolge der Voraussetzungen.\n", "end nat -- hide"]]}