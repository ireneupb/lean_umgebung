{"name": "Die nat\u00fcrlichen Zahlen", "version": "2.0", "languages": ["en"], "translated_name": "0", "devmode": false, "library_zip_fn": "Die nat\u00fcrlichen Zahlen-2.0-library.zip", "introData": {"name": "1", "problemIndex": -1, "objects": [{"type": "text", "content": "2"}]}, "worlds": [{"name": "3", "levels": [{"name": "4", "problemIndex": 8, "objects": [{"type": "lean", "content": "5", "hidden": true}, {"type": "lean", "content": "6", "hidden": true}, {"type": "lean", "content": "7", "hidden": true}, {"type": "text", "content": "8"}, {"type": "hint", "content": "9", "title": "10"}, {"type": "text", "content": "11"}, {"type": "hint", "content": "12", "title": "13"}, {"type": "text", "content": "14"}, {"type": "theorem", "text": "15", "lean": "theorem succ_succ (a b : N) (h : succ(a) = b): succ(succ(a)) = succ(b) :=\n", "sideBar": true, "firstProofLineNumber": 84, "lastProofLineNumber": 87, "textBefore": "-- Level name : Die Peano Axiome\n\n-- namespace nat -- hide \n\nimport mynat.definition -- hide\nnamespace N -- hide\n\n/-\nDie nat\u00fcrlichen Zahlen k\u00f6nnen mit Peanos Axiomen eindeutig definiert werden. Die\nAxiome lauten wie folgt:\n- $A_1$: $0$ (in LEAN: `zero`) ist eine nat\u00fcrliche Zahl \n- $A_2$: Es gibt eine injektive Abbildung `succ`$: \\mathbb{N} \\to \\mathbb{N}$, die f\u00fcr jede nat\u00fcrliche Zahl ihren Nachfolger angibt.\n- $A_3$: $0$ ist nicht der Nachfolger einer nat\u00fcrlichen Zahl.\n- $A_4$: Das Prinzip der Induktion: Enth\u00e4lt eine Menge die $0$ und f\u00fcr jede enthaltene nat\u00fcrliche Zahl $n$ auch ihren Nachfolger `succ`$(n)$, so enth\u00e4lt sie alle nat\u00fcrlichen Zahlen.\n\nIn LEAN kann man die Anwendung der Abbildung `succ` auf `a` sowohl als `succ(a)` als auch \nals `a.succ` schreiben.\n-/\n\n/- Hint : Wieso brauchen wir hier die Abbildung `succ`, um den Nachfolger einer Zahl $n$ zu beschreiben, anstatt den Ausdruck n+1 zu verwenden?\nWir haben die Addition noch nicht definiert. Au\u00dferdem ist `succ`$(n)=n+1$ mit $1=$`succ`$(0)$ dann noch zu beweisen.\n-/\n\n/-\nAus diesen Axiomen werden wir alles herleiten und beweisen, was wir in dieser Einheit\nvorhaben. In diesem Level werden wir folgende Aussage zur Funktion `succ` zeigen: F\u00fcr die nat\u00fcrlichen Zahlen a und b gilt: falls `succ(a)=b` dann `succ(succ(a))=succ(b)`.\n\nDiese Aussage kann man direkt zeigen, indem man die gegebene Hypothese `succ(a)=b` in die\nzu zeigende Aussage `succ(succ(a))=succ(b)` einsetzt und somit `succ(b)=succ(b)` erh\u00e4lt.\n\nWir schauen uns nun an, wie das in LEAN funktioniert. Wir werden mit der Klasse\nN arbeiten, die genau nach den Axiomen von Peano definiert ist.\n-/\n\n/- Hint : Klicke hier, um die Definition der nat\u00fcrlichen Zahlen in LEAN zu sehen. Du musst diesen Code nicht zu 100% verstehen.\n`inductive N` \u2192 $A_4$ <br>\n`| zero : N` \u2192 $A_1$ <br>\n`| succ (n : N) : N` \u2192 $A_2$ <br>\n`lemma succ_inj {m n : N} (h : succ m = succ n) : m = n := by cases h; refl` \u2192 $A_2$ <br>\n`lemma zero_ne_succ (m : N) : (zero : N) \u2260 succ m := \u03bb h, by cases h` \u2192 $A_3$\n-/\n\n/-\nAls Erstes muss man das Lemma definieren, das man beweisen m\u00f6chte. Dies besteht aus drei \nTeilen.\n- Name: Der Name kann beliebig gew\u00e4hlt werden, ist im besten Fall aber eine gute \nBeschreibung des Lemmas. Hier kann man zum Beispiel \u201csucc_succ\u201d w\u00e4hlen, um anzudeuten, \ndass es um die Zweifachanwendung der Abbildung `succ` geht.\n- Voraussetzungen: Diese stehen zwischen dem Namen und dem Doppelpunkt. In diesem Fall\nsind das, dass a und b nat\u00fcrliche Zahlen sind und die Aussage h, dass `succ(a)=b`.\n- Folgerung: Diese steht zwischen dem Doppelpunkt und dem Definitionszeichen. In diesem\nFall also, `succ(succ(a))=b`.\n\nDer Beweis folgt zwischen dem `begin` und dem `end`. Zu Beginn der Bearbeitung steht im\nBeweis immer `sorry`. Dies ist ein Keyword, was so viel bedeutet wie: \"Hier fehlt ein\nTeil des Beweises\". Du kannst dieses Keyword verwenden, wenn ein Beweis \u00fcberpr\u00fcft werden\nsoll, bei dem dir noch ein Teil fehlt. LEAN wird best\u00e4tigen, dass der Beweis stimmt, aber\nmit dem warning \"uses `sorry`\" darauf hinweisen, dass noch etwas zu tun ist. L\u00f6sche als\nErstes das `sorry`, um mit dem Beweis zu starten.\n\nWir haben oben bereits beschrieben, wie der Beweis mathematisch funktioniert. Wie \n\u00fcbertragen wir die Idee in LEAN? Dazu gibt es den `rw` (rewrite) Befehl. Wenn `h` eine\nAussage ist (z.B. $a=b$), dann bewirkt `rw h,`, dass LEAN die Aussage `h` in der zu \nzeigenden Aussage einsetzt (im Beispiel w\u00fcrde also in der zu zeigenden Aussage jedes $a$\nmit einem $b$ ersetzt werden). Probiere also den Befehl `rw h,` aus. Das Komma am Ende \njedes LEAN-Befehls ist sehr wichtig. Wenn du Fehlermeldungen bekommst, die du nicht\nverstehst, \u00fcberpr\u00fcfe deinen Code auf fehlende Kommata.\n\nDie rechte Spalte:\nHier gibt LEAN dynamisches Feedback. Bis auf die letzte Zeile steht hier immer was \ngegeben ist, in diesem Fall zum Beispiel, dass a und b nat\u00fcrliche Zahlen sind und die\nAussage `h`. In der letzten Zeile, nach dem `\u22a2` Symbol, steht immer das aktuelle Ziel, \nalso das, was gerade zu  zeigen ist. Wenn man am Anfang des Beweises steht, ist das \nnoch die ganze Aussage des Lemmas. Nachdem man `rw h,` eingibt, sieht man, dass sich \nder Zustand \u00e4ndert. In diesem Fall kommt die Nachricht `Proof complete!`, die uns \nangibt, dass wir fertig sind. In l\u00e4ngeren Aufgaben w\u00fcrde hier das neue Ziel stehen.\n-/\n\n/- Theorem\nFalls `succ`$(a) = b$, dann `succ`$($`succ`$(a)) = $`succ`$(b)$\n-/\ntheorem succ_succ (a b : N) (h : succ(a) = b): succ(succ(a)) = succ(b) :=\nbegin\n", "proof": "rw h,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : rw\n## Anleitung\nWenn `h` eine Aussage des Typs `X = Y` ist, dann wird\n`rw h,` alle `X` in der zu beweisenden Aussage durch\n`Y` austauschen.\nUm alle `Y` durch `X` zu ersetzten verwendet man `rw \u2190 h`.\n## Beispiel\nBei folgendem Zustand:\n```\nx : N\n\u22a2 succ (x + 0) = succ (x)\n```\nwird `rw add_zero,` das Ziel um\u00e4ndern zu `\u22a2 succ x = succ (x)`,\nund damit den Beweis abschlie\u00dfen.\n-/\n\nend N -- hide", "height": 4, "editorText": "sorry", "lineOffset": 83, "name": "succ_succ", "statement": "(a b : N) (h : succ(a) = b): succ(succ(a)) = succ(b)"}, {"type": "tactic", "content": "16", "name": "rw", "sideBar": true}, {"type": "lean", "content": "17", "hidden": true}]}, {"name": "18", "problemIndex": 5, "objects": [{"type": "lean", "content": "19", "hidden": true}, {"type": "lean", "content": "20", "hidden": true}, {"type": "lean", "content": "21", "hidden": true}, {"type": "lean", "content": "22", "hidden": true}, {"type": "text", "content": "23"}, {"type": "theorem", "text": "24", "lean": "theorem succ_succ_c (a b c : N) (h : succ(a) = b) (g : succ(b) = c): succ(succ(a)) = c :=\n", "sideBar": true, "firstProofLineNumber": 36, "lastProofLineNumber": 40, "textBefore": "-- Level name : Die Peano Axiome - Teil 2\n\n-- namespace nat -- hide \n\nimport mynat.definition -- hide\nimport game.Peano.level_1 --hide\nnamespace N -- hide\n\n/-\nIn diesem Level passiert nicht viel. Es dient eher zur \u00dcbung von dem Gelernten in\nLevel 1.\n\nVielleicht hast du gemerkt, dass es eine linke Spalte gibt. Hier kannst du alle\nTools finden, die du zum Beweisen brauchst. Das sind einerseits die Befehle (wie\nz.B. `rw`), die in LEAN Tactics hei\u00dfen. Andererseits sind das die Axiome und Aussagen,\ndie wir bereits eingef\u00fchrt/bewiesen haben. Diese sind in der Kategorie Theorem\nstatements. Umso weiter du bist, umso mehr Inhalt wirst du hier finden.\n\nWir werden aber auch die Gelegenheit nutzen, um uns den `rw` Befehl nochmal\nanzuschauen. Wir haben gesehen, dass f\u00fcr die Aussage `h: a = b` der Befehl\n`rw h,` in der zu zeigenden Aussage jedes `a` durch ein `b` ersetzt. Aber wie\nkann man jedes `b` durch ein `a` ersetzen? Dazu verwendet man den Befehl\n`rw \u2190 h,`. Der Pfeil steht sozusagen daf\u00fcr, dass LEAN die Aussage h von rechts\nnach links lesen soll. Du kannst den Pfeil mit \\ l (backslash + klein L)\nschreiben.\n\nDu kannst das untenstehende Lemma \u00e4hnlich wie Level 1 l\u00f6sen, aber erkennst du\nauch einen weiteren Weg?\n-/\n\n/- Theorem\nFalls `succ`$(a) = b$ und `succ`$(b)= c$, dann `succ`$($`succ`$(a)) = c$\n-/\ntheorem succ_succ_c (a b c : N) (h : succ(a) = b) (g : succ(b) = c): succ(succ(a)) = c :=\nbegin\n", "proof": "rw h,\nrw g,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide\n\n/- Hint : Brauchst du Hilfe, um einen zweiten Weg zu finden?\nIn der zu zeigenden Aussage kommt der Term `c` vor, der auch Teil der Aussage\n`g` ist. Du kannst also mit `rw \u2190 g,` das `c` in der Aussage ersetzen.\n-/", "height": 5, "editorText": "sorry", "lineOffset": 35, "name": "succ_succ_c", "statement": "(a b c : N) (h : succ(a) = b) (g : succ(b) = c): succ(succ(a)) = c"}, {"type": "lean", "content": "25", "hidden": true}, {"type": "hint", "content": "26", "title": "27"}]}, {"name": "28", "problemIndex": 5, "objects": [{"type": "lean", "content": "29", "hidden": true}, {"type": "lean", "content": "30", "hidden": true}, {"type": "lean", "content": "31", "hidden": true}, {"type": "lean", "content": "32", "hidden": true}, {"type": "text", "content": "33"}, {"type": "theorem", "text": "34", "lean": "theorem succ_succ_c_anders (a b c : N) (h : succ(a) = b) (g : succ(b) = c): succ(succ(a)) = c :=\n", "sideBar": true, "firstProofLineNumber": 18, "lastProofLineNumber": 22, "textBefore": "-- Level name : Die Peano Axiome - Teil 2\n\n-- namespace nat -- hide \n\nimport mynat.definition -- hide\nimport game.Peano.level_2 --hide\nnamespace N -- hide\n\n/-\n\n-/\n\n/- Theorem\nFalls `succ`$(a) = b$ und `succ`$(b)= c$, dann `succ`$($`succ`$(a)) = c$\n-/\ntheorem succ_succ_c_anders (a b c : N) (h : succ(a) = b) (g : succ(b) = c): succ(succ(a)) = c :=\nbegin\n", "proof": "rw [\u2190h] at g,\nexact g,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide\n\n/- Hint : Brauchst du Hilfe, um einen zweiten Weg zu finden?\nIn der zu zeigenden Aussage kommt der Term `c` vor, der auch Teil der Aussage\n`g` ist. Du kannst also mit `rw \u2190 g,` das `c` in der Aussage ersetzen.\n-/", "height": 5, "editorText": "sorry", "lineOffset": 17, "name": "succ_succ_c_anders", "statement": "(a b c : N) (h : succ(a) = b) (g : succ(b) = c): succ(succ(a)) = c"}, {"type": "lean", "content": "35", "hidden": true}, {"type": "hint", "content": "36", "title": "37"}]}]}, {"name": "38", "levels": [{"name": "39", "problemIndex": 7, "objects": [{"type": "lean", "content": "40", "hidden": true}, {"type": "lean", "content": "41", "hidden": true}, {"type": "lean", "content": "42", "hidden": true}, {"type": "lean", "content": "43", "hidden": true}, {"type": "text", "content": "44"}, {"type": "hint", "content": "45", "title": "46"}, {"type": "text", "content": "47"}, {"type": "theorem", "text": "48", "lean": "theorem succ_add_zero (a : N) : succ(a)+0=succ(a+0) :=\n", "sideBar": true, "firstProofLineNumber": 26, "lastProofLineNumber": 27, "textBefore": "-- Level name : TBD\n\n-- namespace nat -- hide \nimport mynat.add -- hide\nimport game.Peano.level_3 -- hide\nnamespace N -- hide\n\n/-\nHier: SPEZIFIZIERUNG!\n-/\n\n/- Hint : Hint Title?\nHint teeeext.\n-/\n\n/-\nMore teeeeext (8)\n-/\n\n/- Theorem\nTBD\n-/\n\ntheorem succ_add_zero (a : N) : succ(a)+0=succ(a+0) :=\nbegin\n", "proof": "rw add_zero a,\nrw add_zero a.succ,", "proof_hint": "sorry", "textAfter": "\nend\n\n\n/- Tactic : rw\n## Anleitung\nWenn `h` eine Aussage des Typs `X = Y` ist, dann wird\n`rw h,` alle `X` in der zu beweisenden Aussage durch\n`Y` austauschen.\nUm alle `Y` durch `X` zu ersetzten verwendet man `rw \u2190 h`.\n## Beispiel\nBei folgendem Zustand:\n```\nx : N\n\u22a2 succ (x + 0) = succ (x)\n```\nwird `rw add_zero,` das Ziel um\u00e4ndern zu `\u22a2 succ x = succ (x)`,\nund damit den Beweis abschlie\u00dfen.\n-/\n\nend N -- hide", "height": 2, "editorText": "sorry", "lineOffset": 25, "name": "succ_add_zero", "statement": "(a : N) : succ(a)+0=succ(a+0)"}, {"type": "tactic", "content": "49", "name": "rw", "sideBar": true}, {"type": "lean", "content": "50", "hidden": true}]}, {"name": "51", "problemIndex": 8, "objects": [{"type": "lean", "content": "52", "hidden": true}, {"type": "lean", "content": "53", "hidden": true}, {"type": "lean", "content": "54", "hidden": true}, {"type": "axiom", "content": "55", "name": "add_zero (a : N) :", "sideBar": true}, {"type": "axiom", "content": "56", "name": "add_succ (a b : N) :", "sideBar": true}, {"type": "text", "content": "57"}, {"type": "hint", "content": "58", "title": "59"}, {"type": "text", "content": "60"}, {"type": "theorem", "text": "61", "lean": "theorem add_succ_zero (a : N) : a + succ(0) = succ(a) :=\n", "sideBar": true, "firstProofLineNumber": 52, "lastProofLineNumber": 56, "textBefore": "-- Level name : Die Addition\n\nimport mynat.add -- hide\nimport game.Addition.level_1 --hide\nnamespace N -- hide\n\n/- Axiom : add_zero (a : N) :\na + 0 = a\n-/\n\n/- Axiom : add_succ (a b : N) :\na + succ(b) = succ(a + b)\n-/\n\n\n/-\nMan kann die Addition zweier nat\u00fcrlichen Zahlen rekursiv anhand der Peano-Axiome \ndefinieren.\n- F\u00fcr $a \\in \\mathbb{N}$ sei $a+0=a$\n- F\u00fcr $a,d \\in \\mathbb{N}$ sei $a+$`succ`$(d) = $`succ`$(a+d)$\n\nNach dem Prinzip der Induktion ist dann die Addition f\u00fcr alle Paare von nat\u00fcrlichen\nZahlen definiert.\n\nDie beiden Aussagen, die die Addition definieren, sind in LEAN implementiert und \nhaben jeweils den Namen `add_zero` und `add_succ`. Auch diese Aussagen k\u00f6nnen mit\ndem Befehl `rw` verwendet werden. `rw add_zero,` wandelt die Aussage `b+zero` in `b`\num.\n-/\n\n/- Hint : Klicke hier, um die Definition der Addition der nat\u00fcrlichen Zahlen in LEAN zu sehen. Du musst diesen Code nicht zu 100% verstehen.\nDefinition: <br>\n`def add : N \u2192 N \u2192 N` <br>\n`| m 0 := m` <br>\n`| m (succ n) := succ (add m n)` <br>\n\nDen beiden definierenden Eigenschaften wird ein Namen gegeben: <br>\n`lemma add_zero (m : N) : m + zero = m := rfl` <br>\n`lemma add_succ (m n : N) : m + succ n = succ (m + n) := rfl`\n-/\n\n/-\nIn diesem Level werden wir zeigen, dass Addition mit dem Nachfolger von $0$ (den\nwir noch nicht formal als $1$ eingef\u00fchrt haben), gleich dem Nachfolger der Zahl ist.\n-/\n\n/- Theorem\n$a+$`succ`$(0)=$`succ`$(a)$\n-/\ntheorem add_succ_zero (a : N) : a + succ(0) = succ(a) :=\nbegin\n", "proof": "  rw add_succ,\n  rw add_zero,\n\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide", "height": 5, "editorText": "sorry", "lineOffset": 51, "name": "add_succ_zero", "statement": "(a : N) : a + succ(0) = succ(a)"}, {"type": "lean", "content": "62", "hidden": true}]}, {"name": "63", "problemIndex": 7, "objects": [{"type": "lean", "content": "64", "hidden": true}, {"type": "lean", "content": "65", "hidden": true}, {"type": "lean", "content": "66", "hidden": true}, {"type": "axiom", "content": "67", "name": "one_eq_succ_zero (a : N) :", "sideBar": true}, {"type": "text", "content": "68"}, {"type": "hint", "content": "69", "title": "70"}, {"type": "text", "content": "71"}, {"type": "theorem", "text": "72", "lean": "theorem succ_eq_add_one (a : N) : succ(a) = a + 1 :=\n", "sideBar": true, "firstProofLineNumber": 32, "lastProofLineNumber": 37, "textBefore": "-- Level name : Die nat\u00fcrliche Zahl 1\n\nimport mynat.add -- hide\nimport game.Addition.level_2 --hide\nnamespace N -- hide\n\n/- Axiom : one_eq_succ_zero (a : N) :\none = succ(zero)\n-/\n\n/-\nTODO: simp!!\nAus praktischen Gr\u00fcnden m\u00f6chten wir nun dem Nachfolger von $0$ einen Namen\ngeben. Diese Zahl nennen wir $1$. Die Aussage `one = succ(zero)` hei\u00dft in\nLEAN `one_eq_succ_zero`.\n-/\n\n/- Hint : Klicke hier, um die Definition der Nummer $1$ in LEAN zu sehen. Du musst diesen Code nicht zu 100% verstehen.\n`def one : N := succ zero` <br>\n`theorem one_eq_succ_zero : one = succ zero := rfl`\n-/\n\n/- \nNun k\u00f6nnen wir zeigen, dass der Nachfolger von $a$ gleich $a+1$ ist. \n-/\n\n/- Theorem\n`succ`$(a) = a + 1$\n-/\ntheorem succ_eq_add_one (a : N) : succ(a) = a + 1 :=\nbegin\n", "proof": "rw one_eq_succ_zero,\nrw add_succ,\nrw add_zero,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide", "height": 6, "editorText": "sorry", "lineOffset": 31, "name": "succ_eq_add_one", "statement": "(a : N) : succ(a) = a + 1"}, {"type": "lean", "content": "73", "hidden": true}]}, {"name": "74", "problemIndex": 5, "objects": [{"type": "lean", "content": "75", "hidden": true}, {"type": "lean", "content": "76", "hidden": true}, {"type": "lean", "content": "77", "hidden": true}, {"type": "tactic", "content": "78", "name": "induction", "sideBar": true}, {"type": "text", "content": "79"}, {"type": "theorem", "text": "80", "lean": "theorem zero_add (a : N) : 0 + a = a :=\n", "sideBar": true, "firstProofLineNumber": 62, "lastProofLineNumber": 69, "textBefore": "-- Level name : Addition mit 0 - von links\n\nimport mynat.add -- hide\nimport game.Addition.level_3 --hide\nnamespace N -- hide\n\n/- Tactic : induction\n## Anleitung\nfalls `n : N` gegeben ist, dann startet `induction n with d hd`\neinen Induktionsbeweis \u00fcber `n` der zu beweisenden Aussage. `d` wird \nder Name der Variable im Induktionsschritt sein, und `hd` ist die Aussage\nder Induktionsvoraussetzung.\n## Beispiel\nBei folgendem Zustand:\n```\nn : N\n\u22a2 2 * n = n + n\n```\ndann wird `induction n with d hd` zwei neue Ziele \u00f6ffnen:\n```\n\u22a2 2 * 0 = 0 + 0\n```\nund\n```\nd : mynat,\nhd : 2 * d = d + d\n\u22a2 2 * succ d = succ d + succ d\n```\n-/\n\n/-\nNach Definition der Addition gilt: $a+0=a$. Wir haben aber noch nicht bewiesen,\ndass die Addition kommutativ ist. Es ist also noch nicht bewiesen, dass auch\n$0+a=a$ gilt.\n\nDies werden wir \u00fcber Induktion zeigen. Dazu lernen wir den `induction` Befehl in\nLEAN. Um einen Induktionsbeweis zu starten, m\u00fcssen wir `induction a with d hd,`\naufrufen. Dabei ist das $a$ die Variable, \u00fcber die induziert werden soll, $d$\nwird der Name der Variable im Induktionsschritt sein, und `hd` ist die Aussage\nder Induktionsvoraussetzung.\n\nNachdem du den Befehl `induction a with d hd,` eingibst, wirst du in der rechten\nSpalte sehen, dass du zwei Beweisziele hast: den Induktionsanfang und die \nInduktionsvoraussetzung. Um den Beweis \u00fcbersichtlicher zu f\u00fchren, kannst du\ndie zwei Teile mit geschweiften Klammern umgeben. Dein Beweis hat dann die Form: <br>\n`begin` <br>\n  `induction a with d hd,` <br>\n  `{},` <br>\n  `{},` <br>\n`end` <br>\nInnerhalb der geschweiften Klammern kannst du dann jeweils den Induktionsanfang und\nden Induktionsschritt zeigen.\n\nZu diesem Beweis gibt es <a href=\"https://go.upb.de/lean_2_3\" target=\"blank\">hier</a> ein Aufgabenblatt.\n-/\n\n/- Theorem\n$0+a=a$\n-/\ntheorem zero_add (a : N) : 0 + a = a :=\nbegin\n", "proof": "  induction a with d hd,\n  {rw N_zero_eq_zero,\n   rw add_zero,},\n  {rw add_succ,\n  rw hd,},\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide", "height": 8, "editorText": "sorry", "lineOffset": 61, "name": "zero_add", "statement": "(a : N) : 0 + a = a"}, {"type": "lean", "content": "81", "hidden": true}]}, {"name": "82", "problemIndex": 6, "objects": [{"type": "lean", "content": "83", "hidden": true}, {"type": "lean", "content": "84", "hidden": true}, {"type": "lean", "content": "85", "hidden": true}, {"type": "text", "content": "86"}, {"type": "hint", "content": "87", "title": "88"}, {"type": "text", "content": "89"}, {"type": "theorem", "text": "90", "lean": "theorem add_assoc (a b c : N) : (a + b) + c = a + (b + c) :=\n", "sideBar": true, "firstProofLineNumber": 30, "lastProofLineNumber": 40, "textBefore": "-- Level name : Assoziativit\u00e4t der Addition\n\nimport mynat.add -- hide\nimport game.Addition.level_4 --hide\nnamespace N -- hide\n\n/-\nNun werden wir die Assoziativit\u00e4t der Addition der nat\u00fcrlichen\nZahlen zeigen. Das bedeutet $(a + b) + c = a + (b + c)$. \n-/\n\n/- Hint : \u00dcber welcher der drei Variablen ist ein Induktionsbeweis am sinnvollsten?\nWir haben die Addition mit Rekursion auf die rechte Variable definiert,\nes ist also sinnvoll bei dem Induktionsbeweis \u00fcber die Variable\n$c$ zu induzieren.\n-/\n\n/-\nNoch eine Bemerkung: LEAN ist linksassoziativ. Das bedeutet, dass f\u00fcr LEAN\n$a+b+b$ das gleiche wie $(a+b)+c$ ist.\n\nZu diesem Beweis gibt es <a href=\"https://go.upb.de/lean_2_4\" target=\"blank\">hier</a> ein Aufgabenblatt.\n-/\n\n/- Theorem\n$(a + b) + c = a + (b + c)$\n-/\ntheorem add_assoc (a b c : N) : (a + b) + c = a + (b + c) :=\nbegin\n", "proof": "  induction c with d hd,\n  {rw N_zero_eq_zero,\n  rw add_zero,\n  rw add_zero,},\n  {rw add_succ (a+b) d,\n  rw add_succ,\n  rw add_succ,\n  rw hd,},\n\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide", "height": 11, "editorText": "sorry", "lineOffset": 29, "name": "add_assoc", "statement": "(a b c : N) : (a + b) + c = a + (b + c)"}, {"type": "lean", "content": "91", "hidden": true}]}, {"name": "92", "problemIndex": 5, "objects": [{"type": "lean", "content": "93", "hidden": true}, {"type": "lean", "content": "94", "hidden": true}, {"type": "lean", "content": "95", "hidden": false}, {"type": "lean", "content": "96", "hidden": true}, {"type": "text", "content": "97"}, {"type": "theorem", "text": "98", "lean": "theorem succ_add (a b: N) : succ(a) + b = succ(a + b) :=\n", "sideBar": true, "firstProofLineNumber": 19, "lastProofLineNumber": 28, "textBefore": "-- Level name : Addition mit dem Nachfolger - von links\n\nimport mynat.add -- hide\nimport game.Addition.level_5 --hide\nimport tactic\nnamespace N -- hide\n\n/-\nGenauso wie wir aus $a+0=a$ nicht direkt $0+a=a$ folgern k\u00f6nnten, k\u00f6nnen wir\naus $b + $`succ`$(a) =$ `succ`$(b+a)$ nicht `succ`$(a)+b =$ `succ`$(a+b)$\nfolgern. Wir haben n\u00e4mlich noch nicht bewiesen, dass die Addition kommutativ ist.\n-/\n\n/- Theorem\n`succ`$(a)+b = $`succ`$(a+b)$\n-/\ntheorem succ_add (a b: N) : succ(a) + b = succ(a + b) :=\nbegin\n", "proof": "  induction b with d hd,\n  {rw N_zero_eq_zero,\n  rw add_zero,\n  rw add_zero,},\n  {rw add_succ,\n  rw hd,\n  rw add_succ,},\n\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide", "height": 10, "editorText": "sorry", "lineOffset": 18, "name": "succ_add", "statement": "(a b: N) : succ(a) + b = succ(a + b)"}, {"type": "lean", "content": "99", "hidden": true}]}, {"name": "100", "problemIndex": 4, "objects": [{"type": "lean", "content": "101", "hidden": true}, {"type": "lean", "content": "102", "hidden": true}, {"type": "lean", "content": "103", "hidden": true}, {"type": "text", "content": "104"}, {"type": "theorem", "text": "105", "lean": "theorem add_comm (a b: N) : a + b = b + a :=\n", "sideBar": true, "firstProofLineNumber": 18, "lastProofLineNumber": 29, "textBefore": "-- Level name : Kommutativit\u00e4t der Addition\n\nimport mynat.add -- hide\nimport game.Addition.level_6 --hide\nnamespace N -- hide\n\n/-\nEndlich k\u00f6nnen wir zeigen, dass die Addition kommutativ ist!\n\nZu diesem Beweis gibt es <a href=\"https://go.upb.de/lean_2_6\" target=\"blank\">hier</a> ein Aufgabenblatt.\n-/\n\n/- Theorem\na+b=b+a\n-/\ntheorem add_comm (a b: N) : a + b = b + a :=\nbegin\n", "proof": "  induction b with d hd,\n  {/- Induktionsanfang -/\n  rw N_zero_eq_zero,\n  rw add_zero,\n  rw zero_add,},\n  {/- Induktionsschritt -/\n  rw add_succ,\n  rw hd,\n  rw succ_add,},\n\n\n  ", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide", "height": 12, "editorText": "sorry", "lineOffset": 17, "name": "add_comm", "statement": "(a b: N) : a + b = b + a"}, {"type": "lean", "content": "106", "hidden": true}]}, {"name": "107", "problemIndex": 4, "objects": [{"type": "lean", "content": "108", "hidden": true}, {"type": "lean", "content": "109", "hidden": true}, {"type": "lean", "content": "110", "hidden": true}, {"type": "text", "content": "111"}, {"type": "theorem", "text": "112", "lean": "theorem add_right_comm (a b c: N) : a + b + c = a + c + b :=\n", "sideBar": true, "firstProofLineNumber": 28, "lastProofLineNumber": 33, "textBefore": "-- Level name : Kommutativit\u00e4t der rechten Summanden\n\nimport mynat.add -- hide\nimport game.Addition.level_7 --hide\nnamespace N -- hide\n\n/-\nDas Ziel dieses Levels ist $a+b+c=a+c+b$. Das sieht vielleicht erstmal danach aus,\ndass du nur `add_comm,` anwenden muss. Aber LEAN ist links-assoziativ. Das bedeutet,\ndass diese Aussage mit Klammern so geschrieben werden kann: $(a+b)+c=(a+c)+b$. Um\ndieses Lemma zu zeigen, wirst du also auch die Assoziativit\u00e4t verwenden. Dieses\nLemma wird dir in zuk\u00fcnftigen Beweisen etwas Schreibarbeit sparen.\n\nNoch eine Bemerkung: manchmal gibt es mehr als eine Stelle, an der `rw` etwas\nanstellen kann. Wenn du nichts Weiteres spezifizierst, wird LEAN die erste dieser\nStellen heraussuchen. Wenn du zum Beispiel in diesem Level damit anfangen m\u00f6chtest,\ndass du auf der rechten Seite $a+c+b$ zu $a+(c+b)$ umschreibst, wird das nicht mit\ndem Befehl `rw add_assoc,` klappen. Dies wird n\u00e4mlich in der linken Seite der Gleichung\ndie Assoziativit\u00e4t ausnutzen. Du kannst LEAN konkret angeben an welcher Stelle du die\n\u00c4nderung m\u00f6chtest, in diesem Fall: `rw add_assoc a c b,`.\n-/\n\n/- Theorem\n$a+b+c=a+c+b$\n-/\ntheorem add_right_comm (a b c: N) : a + b + c = a + c + b :=\nbegin\n", "proof": "rw add_assoc a b c,\nrw add_comm b c,\nrw \u2190 add_assoc a c b,\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide", "height": 6, "editorText": "sorry", "lineOffset": 27, "name": "add_right_comm", "statement": "(a b c: N) : a + b + c = a + c + b"}, {"type": "lean", "content": "113", "hidden": true}]}, {"name": "114", "problemIndex": 4, "objects": [{"type": "lean", "content": "115", "hidden": true}, {"type": "lean", "content": "116", "hidden": true}, {"type": "lean", "content": "117", "hidden": true}, {"type": "text", "content": "118"}, {"type": "theorem", "text": "119", "lean": "theorem add_10 : (\u2203 n m : \u2115, n+m=10) :=\n", "sideBar": true, "firstProofLineNumber": 28, "lastProofLineNumber": 28, "textBefore": "-- Level name : Kommutativit\u00e4t der rechten Summanden\n\nimport data.nat.basic -- hide\nimport tactic -- hide\nnamespace nat -- hide\n\n/-\nDas Ziel dieses Levels ist $a+b+c=a+c+b$. Das sieht vielleicht erstmal danach aus,\ndass du nur `add_comm,` anwenden muss. Aber LEAN ist links-assoziativ. Das bedeutet,\ndass diese Aussage mit Klammern so geschrieben werden kann: $(a+b)+c=(a+c)+b$. Um\ndieses Lemma zu zeigen, wirst du also auch die Assoziativit\u00e4t verwenden. Dieses\nLemma wird dir in zuk\u00fcnftigen Beweisen etwas Schreibarbeit sparen.\n\nNoch eine Bemerkung: manchmal gibt es mehr als eine Stelle, an der `rw` etwas\nanstellen kann. Wenn du nichts Weiteres spezifizierst, wird LEAN die erste dieser\nStellen heraussuchen. Wenn du zum Beispiel in diesem Level damit anfangen m\u00f6chtest,\ndass du auf der rechten Seite $a+c+b$ zu $a+(c+b)$ umschreibst, wird das nicht mit\ndem Befehl `rw add_assoc,` klappen. Dies wird n\u00e4mlich in der linken Seite der Gleichung\ndie Assoziativit\u00e4t ausnutzen. Du kannst LEAN konkret angeben an welcher Stelle du die\n\u00c4nderung m\u00f6chtest, in diesem Fall: `rw add_assoc a c b,`.\n-/\n\n/- Theorem\n$a+b+c=a+c+b$\n-/\ntheorem add_10 : (\u2203 n m : \u2115, n+m=10) :=\nbegin\n", "proof": "use [4,6],", "proof_hint": "sorry", "textAfter": "\nend\n\nend nat -- hide", "height": 1, "editorText": "sorry", "lineOffset": 27, "name": "add_10", "statement": "(\u2203 n m : \u2115, n+m=10)"}, {"type": "lean", "content": "120", "hidden": true}]}, {"name": "121", "problemIndex": 7, "objects": [{"type": "lean", "content": "122", "hidden": true}, {"type": "lean", "content": "123", "hidden": true}, {"type": "lean", "content": "124", "hidden": true}, {"type": "lean", "content": "125", "hidden": true}, {"type": "text", "content": "126"}, {"type": "hint", "content": "127", "title": "128"}, {"type": "text", "content": "129"}, {"type": "theorem", "text": "130", "lean": "theorem lineare_gleichung (n : \u2115) (h : n+3=8) : n=5 :=\n", "sideBar": true, "firstProofLineNumber": 26, "lastProofLineNumber": 26, "textBefore": "-- Level name : TBD\n\n-- namespace nat -- hide \n\nimport data.nat.basic -- hide\nimport tactic -- hide\nnamespace nat -- hide\n\n/-\nUse needs to be introduced at latest here.\n-/\n\n/- Hint : Hint Title?\nHint teeeext.\n-/\n\n/-\nMore teeeeext (8)\n-/\n\n/- Theorem\nF\u00fcr nat\u00fcrliche Zahlen m,n mit $m>0$ gilt: Es gibt nat\u00fcrliche Zahlen q, r mit $n = m*q + r$\n-/\ntheorem lineare_gleichung (n : \u2115) (h : n+3=8) : n=5 :=\nbegin\n", "proof": "linarith,", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : rw\n## Anleitung\nWenn `h` eine Aussage des Typs `X = Y` ist, dann wird\n`rw h,` alle `X` in der zu beweisenden Aussage durch\n`Y` austauschen.\nUm alle `Y` durch `X` zu ersetzten verwendet man `rw \u2190 h`.\n## Beispiel\nBei folgendem Zustand:\n```\nx : N\n\u22a2 succ (x + 0) = succ (x)\n```\nwird `rw add_zero,` das Ziel um\u00e4ndern zu `\u22a2 succ x = succ (x)`,\nund damit den Beweis abschlie\u00dfen.\n-/\nend nat -- hide", "height": 1, "editorText": "sorry", "lineOffset": 25, "name": "lineare_gleichung", "statement": "(n : \u2115) (h : n+3=8) : n=5"}, {"type": "tactic", "content": "131", "name": "rw", "sideBar": true}, {"type": "lean", "content": "132", "hidden": true}]}, {"name": "133", "problemIndex": 4, "objects": [{"type": "lean", "content": "134", "hidden": true}, {"type": "lean", "content": "135", "hidden": false}, {"type": "lean", "content": "136", "hidden": true}, {"type": "text", "content": "137"}, {"type": "theorem", "text": "138", "lean": "theorem no_name_yet (a : \u2115) (h : a + 2 = 4): a + 3=5 :=\n", "sideBar": true, "firstProofLineNumber": 16, "lastProofLineNumber": 20, "textBefore": "-- Level name : Kommutativit\u00e4t der rechten Summanden\n\nimport data.nat.basic -- hide\nimport tactic\nnamespace nat -- hide\n\n/-\n\n-/\n\n/- Theorem\n$a+b+c=a+c+b$\n-/\ntheorem no_name_yet (a : \u2115) (h : a + 2 = 4): a + 3=5 :=\nbegin\n", "proof": "have ha : a = 2,\n{linarith,},\nrw ha,\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend nat -- hide", "height": 5, "editorText": "sorry", "lineOffset": 15, "name": "no_name_yet", "statement": "(a : \u2115) (h : a + 2 = 4): a + 3=5"}, {"type": "lean", "content": "139", "hidden": true}]}, {"name": "140", "problemIndex": 7, "objects": [{"type": "lean", "content": "141", "hidden": true}, {"type": "lean", "content": "142", "hidden": true}, {"type": "lean", "content": "143", "hidden": true}, {"type": "lean", "content": "144", "hidden": true}, {"type": "text", "content": "145"}, {"type": "hint", "content": "146", "title": "147"}, {"type": "text", "content": "148"}, {"type": "theorem", "text": "149", "lean": "theorem LGS_1 (n m : \u2115) (h : n+m=8 \u2227 succ(m)=1) : n=8 :=\n", "sideBar": true, "firstProofLineNumber": 26, "lastProofLineNumber": 32, "textBefore": "-- Level name : TBD\n\n-- namespace nat -- hide \n\nimport data.nat.basic -- hide\nimport tactic -- hide\nnamespace nat -- hide\n\n/-\nUse needs to be introduced at latest here.\n-/\n\n/- Hint : Hint Title?\nHint teeeext.\n-/\n\n/-\nMore teeeeext (8)\n-/\n\n/- Theorem\nF\u00fcr nat\u00fcrliche Zahlen m,n mit $m>0$ gilt: Es gibt nat\u00fcrliche Zahlen q, r mit $n = m*q + r$\n-/\ntheorem LGS_1 (n m : \u2115) (h : n+m=8 \u2227 succ(m)=1) : n=8 :=\nbegin\n", "proof": "cases h with hnm hm,\nhave h1 : m=0,\n{apply succ.inj,\nexact hm,},\nrw [h1] at hnm,\nrw [add_zero] at hnm,\nexact hnm,", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : rw\n## Anleitung\nWenn `h` eine Aussage des Typs `X = Y` ist, dann wird\n`rw h,` alle `X` in der zu beweisenden Aussage durch\n`Y` austauschen.\nUm alle `Y` durch `X` zu ersetzten verwendet man `rw \u2190 h`.\n## Beispiel\nBei folgendem Zustand:\n```\nx : N\n\u22a2 succ (x + 0) = succ (x)\n```\nwird `rw add_zero,` das Ziel um\u00e4ndern zu `\u22a2 succ x = succ (x)`,\nund damit den Beweis abschlie\u00dfen.\n-/\nend nat -- hide", "height": 7, "editorText": "sorry", "lineOffset": 25, "name": "LGS_1", "statement": "(n m : \u2115) (h : n+m=8 \u2227 succ(m)=1) : n=8"}, {"type": "tactic", "content": "150", "name": "rw", "sideBar": true}, {"type": "lean", "content": "151", "hidden": true}]}, {"name": "152", "problemIndex": 7, "objects": [{"type": "lean", "content": "153", "hidden": true}, {"type": "lean", "content": "154", "hidden": true}, {"type": "lean", "content": "155", "hidden": false}, {"type": "lean", "content": "156", "hidden": true}, {"type": "text", "content": "157"}, {"type": "hint", "content": "158", "title": "159"}, {"type": "text", "content": "160"}, {"type": "theorem", "text": "161", "lean": "theorem LGS_2 (n m : \u2115) (h : n+m+3=8 \u2227 n=m+1) : n=3 \u2227 m=2 :=\n", "sideBar": true, "firstProofLineNumber": 26, "lastProofLineNumber": 34, "textBefore": "-- Level name : TBD\n\n-- namespace nat -- hide \n\nimport data.nat.basic -- hide\nimport tactic\nnamespace nat -- hide\n\n/-\nUse needs to be introduced at latest here.\n-/\n\n/- Hint : Hint Title?\nHint teeeext.\n-/\n\n/-\nMore teeeeext (8)\n-/\n\n/- Theorem\nF\u00fcr nat\u00fcrliche Zahlen m,n mit $m>0$ gilt: Es gibt nat\u00fcrliche Zahlen q, r mit $n = m*q + r$\n-/\ntheorem LGS_2 (n m : \u2115) (h : n+m+3=8 \u2227 n=m+1) : n=3 \u2227 m=2 :=\nbegin\n", "proof": "cases h with h1 h2,\nhave umf : m+1+m+3=8,\n{rw \u2190 h2,\nexact h1,},\nhave hm : m=2, linarith,\nhave hn : n=3, linarith,\nsplit,\n{exact hn,},\n{exact hm,},", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : rw\n## Anleitung\nWenn `h` eine Aussage des Typs `X = Y` ist, dann wird\n`rw h,` alle `X` in der zu beweisenden Aussage durch\n`Y` austauschen.\nUm alle `Y` durch `X` zu ersetzten verwendet man `rw \u2190 h`.\n## Beispiel\nBei folgendem Zustand:\n```\nx : N\n\u22a2 succ (x + 0) = succ (x)\n```\nwird `rw add_zero,` das Ziel um\u00e4ndern zu `\u22a2 succ x = succ (x)`,\nund damit den Beweis abschlie\u00dfen.\n-/\nend nat -- hide", "height": 9, "editorText": "sorry", "lineOffset": 25, "name": "LGS_2", "statement": "(n m : \u2115) (h : n+m+3=8 \u2227 n=m+1) : n=3 \u2227 m=2"}, {"type": "tactic", "content": "162", "name": "rw", "sideBar": true}, {"type": "lean", "content": "163", "hidden": true}]}], "parents": [0]}, {"name": "164", "levels": [{"name": "165", "problemIndex": 8, "objects": [{"type": "lean", "content": "166", "hidden": true}, {"type": "lean", "content": "167", "hidden": true}, {"type": "lean", "content": "168", "hidden": true}, {"type": "axiom", "content": "169", "name": "mul_zero (a : N) :", "sideBar": true}, {"type": "axiom", "content": "170", "name": "mul_succ (a b : N) :", "sideBar": true}, {"type": "text", "content": "171"}, {"type": "hint", "content": "172", "title": "173"}, {"type": "text", "content": "174"}, {"type": "theorem", "text": "175", "lean": "theorem zero_mul (a: N) : 0*a = 0 :=\n", "sideBar": true, "firstProofLineNumber": 49, "lastProofLineNumber": 57, "textBefore": "-- Level name : Die Multiplikation\n\nimport mynat.mul -- hide\nimport game.Addition.level_8 --hide\nnamespace N -- hide\n\n/- Axiom : mul_zero (a : N) :\na * 0 = 0\n-/\n\n/- Axiom : mul_succ (a b : N) :\na * succ(b) = a*d+a\n-/\n\n/-\nMan kann auch die Multiplikation zweier nat\u00fcrlichen Zahlen rekursiv anhand der \nPeano-Axiome definieren.\n- F\u00fcr $a \\in \\mathbb{N}$ sei $a*0=0$\n- F\u00fcr $a,d \\in \\mathbb{N}$ sei $a* $`succ`$(d) = a*d+a$\n\nNach dem Prinzip der Induktion ist dann die Multiplikation f\u00fcr alle Paare von\nnat\u00fcrlichen Zahlen definiert.\n\nDie beiden Aussagen, die die Multiplikation definieren, sind in LEAN implementiert und \nhaben jeweils den Namen `mul_zero` und `mul_succ`.\n-/\n\n/- Hint : Klicke hier, um die Definition der Multiplikation der nat\u00fcrlichen Zahlen in LEAN zu sehen. Du musst diesen Code nicht zu 100% verstehen.\nDefinition: <br>\n`def mul : N \u2192 N \u2192 N` <br>\n`| a zero := zero` <br>\n`| a (succ d) := mul a d + a` <br>\n\nDen beiden definierenden Eigenschaften wird ein Namen gegeben: <br>\n`lemma mul_zero (a : N) : a * zero = zero := rfl` <br>\n`lemma mul_succ (a d : N) : a * (succ d) = a * d + a := rfl`\n-/\n\n/-\nIn diesem Level werden wir zeigen, dass auch die Multiplikation mit $0$ von links $0$ ergibt.\nWir haben die Kommutativit\u00e4t der Multiplikation noch nicht gezeigt.\n-/\n\n/- Theorem\n$0*a=0$\n-/\ntheorem zero_mul (a: N) : 0*a = 0 :=\nbegin\n", "proof": "induction a with d hd,\n{rw N_zero_eq_zero,\nrw mul_zero,},\n{rw mul_succ,\nrw hd,\nrw add_zero,},\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide", "height": 9, "editorText": "sorry", "lineOffset": 48, "name": "zero_mul", "statement": "(a: N) : 0*a = 0"}, {"type": "lean", "content": "176", "hidden": true}]}, {"name": "177", "problemIndex": 5, "objects": [{"type": "lean", "content": "178", "hidden": true}, {"type": "lean", "content": "179", "hidden": true}, {"type": "lean", "content": "180", "hidden": true}, {"type": "tactic", "content": "181", "name": "repeat", "sideBar": true}, {"type": "text", "content": "182"}, {"type": "theorem", "text": "183", "lean": "theorem succ_mul (a b : N) : succ(a) * b = a * b + b :=\n", "sideBar": true, "firstProofLineNumber": 37, "lastProofLineNumber": 50, "textBefore": "-- Level name : Multiplikation mit dem Nachfolger - von links\n\nimport mynat.mul -- hide\nimport game.Multiplikation.level_1 --hide\nnamespace N -- hide\n\n/- Tactic : repeat\n## Anleitung\nfalls du in der zu beweisenden Aussage einen Befehl (z.B. `rw add_zero,`) mehrmals\nanwenden kannst, dann wird `{repeat {\u2b1d,},` den Befehl so oft ausf\u00fchren, bis es\nkeine Instanz mehr gibt, an der der Befehl ausgef\u00fchrt werden kann.\n## Beispiel\nBei folgendem Zustand:\n```\na b : N\n\u22a2 a + zero + b = a + (b + zero)\n```\nwird `{repeat {rw add_zero,},` zweimal `add_zero` anwenden und\nsomit das Ziel zu `\u22a2 a + b = a + b ` umformen und damit\nl\u00f6sen.\n-/\n\n/-\nManchmal m\u00f6chtest du einen Befehl mehrmals hintereinander ausf\u00fchren. Wenn du dir\nzum Beispiel den Induktionsanfang dieses Levels anschaust, musst du zeigen, dass\n`a.succ * zero = a * zero + zero`, du k\u00f6nntest damit anfangen, \u00fcberall wo mit\n$0$ multipliziert wird `rw mul_zero,` anzuwenden. Anstatt den Befehl zweimal\nauszuschreiben, kannst du `{repeat {rw mul_zero,},` anwenden. Dann wird LEAN den\nBefehl `rw mul_zero,` so oft ausf\u00fchren, bis es keine Instanz der Form `a+zero` gibt.\n-/\n\n/- Theorem\n`succ`$(a) * b = a * b + b$\n-/\ntheorem succ_mul (a b : N) : succ(a) * b = a * b + b :=\nbegin\n", "proof": "induction b with d hd,\n{rw N_zero_eq_zero,\nrepeat {rw mul_zero,},\nrw add_zero,},\n{rw mul_succ,\nrw mul_succ,\nrw hd,\nrw add_succ,\nrw add_succ,\nrw add_right_comm,\n},\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide", "height": 14, "editorText": "sorry", "lineOffset": 36, "name": "succ_mul", "statement": "(a b : N) : succ(a) * b = a * b + b"}, {"type": "lean", "content": "184", "hidden": true}]}, {"name": "185", "problemIndex": 4, "objects": [{"type": "lean", "content": "186", "hidden": true}, {"type": "lean", "content": "187", "hidden": true}, {"type": "lean", "content": "188", "hidden": true}, {"type": "text", "content": "189"}, {"type": "theorem", "text": "190", "lean": "theorem mul_comm (a b : N) : a * b = b * a :=\n", "sideBar": true, "firstProofLineNumber": 16, "lastProofLineNumber": 25, "textBefore": "-- Level name : Kommutativit\u00e4t der Multiplikation\n\nimport mynat.mul -- hide\nimport game.Multiplikation.level_2 -- hide\nnamespace N -- hide\n\n/- \nDie Ergebnisse aus Level 1 und 2 sind genug, um die Kommutativit\u00e4t zu zeigen!\n-/\n\n/- Theorem\na * b = b * a\n-/\ntheorem mul_comm (a b : N) : a * b = b * a :=\nbegin\n", "proof": "induction b with d hd,\n{rw N_zero_eq_zero,\nrw mul_zero,\nrw zero_mul,},\n{rw mul_succ,\nrw hd,\nrw succ_mul,},\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide\n\n/- Hint :  Kommen dir die Schritte in diesem Beweis bekannt vor?\nWenn du dir den Beweis der Kommutativit\u00e4t der Addition anschaust und dort\ndas \u00fcberall \"add\" mit \"mul\" ersetzt, hast du einen g\u00fcltigen Beweis f\u00fcr\ndie Kommutativit\u00e4t der Multiplikation!\n-/", "height": 10, "editorText": "sorry", "lineOffset": 15, "name": "mul_comm", "statement": "(a b : N) : a * b = b * a"}, {"type": "lean", "content": "191", "hidden": true}, {"type": "hint", "content": "192", "title": "193"}]}, {"name": "194", "problemIndex": 4, "objects": [{"type": "lean", "content": "195", "hidden": true}, {"type": "lean", "content": "196", "hidden": true}, {"type": "lean", "content": "197", "hidden": true}, {"type": "text", "content": "198"}, {"type": "theorem", "text": "199", "lean": "theorem left_distrib (a b c : N) : c * (a + b) = c * a + c * b :=\n", "sideBar": true, "firstProofLineNumber": 17, "lastProofLineNumber": 29, "textBefore": "-- Level name : Das Distributivgesetz\n\nimport mynat.mul -- hide\nimport game.Multiplikation.level_3 -- hide\nnamespace N -- hide\n\n/-\nDas Distributivgesetz gibt uns an, wie wir mit Ausdr\u00fccken umgehen k\u00f6nnen, in denen\nAddition und Multiplikation vorkommen.\n-/\n\n/- Theorem\n$c * (a + b) = c * a + c * b$\n-/\ntheorem left_distrib (a b c : N) : c * (a + b) = c * a + c * b :=\nbegin\n", "proof": "induction b with d hd,\n{rw N_zero_eq_zero,\nrw add_zero,\nrw mul_zero,\nrw add_zero,},\n{rw add_succ,\nrw mul_succ,\nrw hd,\nrw mul_succ,\nrw add_assoc,},\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide", "height": 13, "editorText": "sorry", "lineOffset": 16, "name": "left_distrib", "statement": "(a b c : N) : c * (a + b) = c * a + c * b"}, {"type": "lean", "content": "200", "hidden": true}]}, {"name": "201", "problemIndex": 4, "objects": [{"type": "lean", "content": "202", "hidden": true}, {"type": "lean", "content": "203", "hidden": true}, {"type": "lean", "content": "204", "hidden": true}, {"type": "text", "content": "205"}, {"type": "theorem", "text": "206", "lean": "theorem mul_assoc (a b c : N) : (a * b) * c = a * (b * c) :=\n", "sideBar": true, "firstProofLineNumber": 18, "lastProofLineNumber": 26, "textBefore": "-- Level name : Assoziativit\u00e4t der Multiplikation\n\nimport mynat.mul -- hide\nimport game.Multiplikation.level_4 -- hide\nnamespace N -- hide\n\n/-\n\n\n\n-/\n\n/- Theorem\n$(a * b) * c = a * (b * c)$\n-/\ntheorem mul_assoc (a b c : N) : (a * b) * c = a * (b * c) :=\nbegin\n", "proof": "induction c with d hd,\n{rw N_zero_eq_zero,\n  repeat {rw mul_zero,},},\n{repeat{rw mul_succ},\nrw left_distrib,\nrw hd,},\n\n\n", "proof_hint": "sorry", "textAfter": "\nend\n\nend N -- hide\n\n/- Hint :  Kannst du auch bei der Assoziativit\u00e4t den Beweis aus der Addition einfach \u00fcbernehmen?\nNein, f\u00fcr diesen Beweis brauchst du n\u00e4mlich das Distributivgesetz. Das kommt daher, dass die \nDefinition der Multiplikation von der Addition abh\u00e4ngt (`a*succ(d)=a*d+a`).\n-/", "height": 9, "editorText": "sorry", "lineOffset": 17, "name": "mul_assoc", "statement": "(a b c : N) : (a * b) * c = a * (b * c)"}, {"type": "lean", "content": "207", "hidden": true}, {"type": "hint", "content": "208", "title": "209"}]}, {"name": "210", "problemIndex": 6, "objects": [{"type": "lean", "content": "211", "hidden": true}, {"type": "lean", "content": "212", "hidden": true}, {"type": "lean", "content": "213", "hidden": true}, {"type": "text", "content": "214"}, {"type": "hint", "content": "215", "title": "216"}, {"type": "text", "content": "217"}, {"type": "theorem", "text": "218", "lean": "theorem mul_gerade (n m : \u2115) (hger : \u2203 o : \u2115, n=2*o) : \u2203 q : \u2115, n*m = 2*q :=\n", "sideBar": true, "firstProofLineNumber": 25, "lastProofLineNumber": 28, "textBefore": "-- Level name : TBD\n\n-- namespace nat -- hide \n\nimport data.nat.basic -- hide\nnamespace nat -- hide\n\n/-\nUse needs to be introduced at latest here.\n-/\n\n/- Hint : Hint Title?\nHint teeeext.\n-/\n\n/-\nMore teeeeext (8)\n-/\n\n/- Theorem\nF\u00fcr nat\u00fcrliche Zahlen m,n mit $m>0$ gilt: Es gibt nat\u00fcrliche Zahlen q, r mit $n = m*q + r$\n-/\ntheorem mul_gerade (n m : \u2115) (hger : \u2203 o : \u2115, n=2*o) : \u2203 q : \u2115, n*m = 2*q :=\nbegin\n", "proof": "  obtain \u27e8o, hger\u27e9 := hger,\n  use [o*m],\n  rw hger,\n  rw mul_assoc,", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : rw\n## Anleitung\nWenn `h` eine Aussage des Typs `X = Y` ist, dann wird\n`rw h,` alle `X` in der zu beweisenden Aussage durch\n`Y` austauschen.\nUm alle `Y` durch `X` zu ersetzten verwendet man `rw \u2190 h`.\n## Beispiel\nBei folgendem Zustand:\n```\nx : N\n\u22a2 succ (x + 0) = succ (x)\n```\nwird `rw add_zero,` das Ziel um\u00e4ndern zu `\u22a2 succ x = succ (x)`,\nund damit den Beweis abschlie\u00dfen.\n-/\n\nend nat -- hide", "height": 4, "editorText": "sorry", "lineOffset": 24, "name": "mul_gerade", "statement": "(n m : \u2115) (hger : \u2203 o : \u2115, n=2*o) : \u2203 q : \u2115, n*m = 2*q"}, {"type": "tactic", "content": "219", "name": "rw", "sideBar": true}, {"type": "lean", "content": "220", "hidden": true}]}], "parents": [1]}, {"name": "221", "levels": [{"name": "222", "problemIndex": 7, "objects": [{"type": "lean", "content": "223", "hidden": true}, {"type": "lean", "content": "224", "hidden": true}, {"type": "lean", "content": "225", "hidden": true}, {"type": "lean", "content": "226", "hidden": true}, {"type": "text", "content": "227"}, {"type": "hint", "content": "228", "title": "229"}, {"type": "text", "content": "230"}, {"type": "theorem", "text": "231", "lean": "theorem kleiner_zwei : \u2203 n : \u2115, n < 2 :=\n", "sideBar": true, "firstProofLineNumber": 26, "lastProofLineNumber": 27, "textBefore": "-- Level name : Ungleichungen TBD\n\n-- namespace nat -- hide \n\nimport data.nat.basic -- hide\nimport tactic -- hide\nnamespace nat -- hide \n\n/-\nHier wird zum ersten Mal use benutzt!!\n-/\n\n/- Hint : Hint Title?\nHint teeeext.\n-/\n\n/-\nMore teeeeext (8)\n-/\n\n/- Theorem\nTBD\n-/\ntheorem kleiner_zwei : \u2203 n : \u2115, n < 2 :=\nbegin\n", "proof": "  use 1,\n  simp,", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : rw\n## Anleitung\nWenn `h` eine Aussage des Typs `X = Y` ist, dann wird\n`rw h,` alle `X` in der zu beweisenden Aussage durch\n`Y` austauschen.\nUm alle `Y` durch `X` zu ersetzten verwendet man `rw \u2190 h`.\n## Beispiel\nBei folgendem Zustand:\n```\nx : N\n\u22a2 succ (x + 0) = succ (x)\n```\nwird `rw add_zero,` das Ziel um\u00e4ndern zu `\u22a2 succ x = succ (x)`,\nund damit den Beweis abschlie\u00dfen.\n-/\nend nat -- hide", "height": 2, "editorText": "sorry", "lineOffset": 25, "name": "kleiner_zwei", "statement": "\u2203 n : \u2115, n < 2"}, {"type": "tactic", "content": "232", "name": "rw", "sideBar": true}, {"type": "lean", "content": "233", "hidden": true}]}, {"name": "234", "problemIndex": 7, "objects": [{"type": "lean", "content": "235", "hidden": true}, {"type": "lean", "content": "236", "hidden": true}, {"type": "lean", "content": "237", "hidden": false}, {"type": "lean", "content": "238", "hidden": true}, {"type": "text", "content": "239"}, {"type": "hint", "content": "240", "title": "241"}, {"type": "text", "content": "242"}, {"type": "theorem", "text": "243", "lean": "theorem Pythagoreisches_Tripel : \u2203 n m o : \u2115, n*n+m*m=o*o :=\n", "sideBar": true, "firstProofLineNumber": 26, "lastProofLineNumber": 27, "textBefore": "-- Level name : Ungleichungen TBD\n\n-- namespace nat -- hide \n\nimport data.nat.basic -- hide\nimport tactic\nnamespace nat -- hide \n\n/-\nText, use mit mehreren Argumenten, linearith!\n-/\n\n/- Hint : Hint Title?\nHint teeeext.\n-/\n\n/-\nMore teeeeext (8)\n-/\n\n/- Theorem\nTBD\n-/\ntheorem Pythagoreisches_Tripel : \u2203 n m o : \u2115, n*n+m*m=o*o :=\nbegin\n", "proof": "  use [3, 4, 5],\n  linarith,", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : rw\n## Anleitung\nWenn `h` eine Aussage des Typs `X = Y` ist, dann wird\n`rw h,` alle `X` in der zu beweisenden Aussage durch\n`Y` austauschen.\nUm alle `Y` durch `X` zu ersetzten verwendet man `rw \u2190 h`.\n## Beispiel\nBei folgendem Zustand:\n```\nx : N\n\u22a2 succ (x + 0) = succ (x)\n```\nwird `rw add_zero,` das Ziel um\u00e4ndern zu `\u22a2 succ x = succ (x)`,\nund damit den Beweis abschlie\u00dfen.\n-/\nend nat -- hide", "height": 2, "editorText": "sorry", "lineOffset": 25, "name": "Pythagoreisches_Tripel", "statement": "\u2203 n m o : \u2115, n*n+m*m=o*o"}, {"type": "tactic", "content": "244", "name": "rw", "sideBar": true}, {"type": "lean", "content": "245", "hidden": true}]}, {"name": "246", "problemIndex": 7, "objects": [{"type": "lean", "content": "247", "hidden": true}, {"type": "lean", "content": "248", "hidden": true}, {"type": "lean", "content": "249", "hidden": false}, {"type": "lean", "content": "250", "hidden": true}, {"type": "text", "content": "251"}, {"type": "hint", "content": "252", "title": "253"}, {"type": "text", "content": "254"}, {"type": "theorem", "text": "255", "lean": "theorem gerades_quadrat : \u2203 n m o : \u2115, n=m+m \u2227 n=o*o :=\n", "sideBar": true, "firstProofLineNumber": 26, "lastProofLineNumber": 29, "textBefore": "-- Level name : Ungleichungen TBD\n\n-- namespace nat -- hide \n\nimport data.nat.basic -- hide\nimport tactic\nnamespace nat -- hide \n\n/-\nText, split\n-/\n\n/- Hint : Hint Title?\nHint teeeext.\n-/\n\n/-\nMore teeeeext (8)\n-/\n\n/- Theorem\nTBD\n-/\ntheorem gerades_quadrat : \u2203 n m o : \u2115, n=m+m \u2227 n=o*o :=\nbegin\n", "proof": "  use [16, 8, 4],\n  split,\n  {linarith,},\n  {linarith,},", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : rw\n## Anleitung\nWenn `h` eine Aussage des Typs `X = Y` ist, dann wird\n`rw h,` alle `X` in der zu beweisenden Aussage durch\n`Y` austauschen.\nUm alle `Y` durch `X` zu ersetzten verwendet man `rw \u2190 h`.\n## Beispiel\nBei folgendem Zustand:\n```\nx : N\n\u22a2 succ (x + 0) = succ (x)\n```\nwird `rw add_zero,` das Ziel um\u00e4ndern zu `\u22a2 succ x = succ (x)`,\nund damit den Beweis abschlie\u00dfen.\n-/\nend nat -- hide", "height": 4, "editorText": "sorry", "lineOffset": 25, "name": "gerades_quadrat", "statement": "\u2203 n m o : \u2115, n=m+m \u2227 n=o*o"}, {"type": "tactic", "content": "256", "name": "rw", "sideBar": true}, {"type": "lean", "content": "257", "hidden": true}]}, {"name": "258", "problemIndex": 7, "objects": [{"type": "lean", "content": "259", "hidden": true}, {"type": "lean", "content": "260", "hidden": true}, {"type": "lean", "content": "261", "hidden": false}, {"type": "lean", "content": "262", "hidden": true}, {"type": "text", "content": "263"}, {"type": "hint", "content": "264", "title": "265"}, {"type": "text", "content": "266"}, {"type": "theorem", "text": "267", "lean": "theorem not_sure (a : \u2115) (h : a \u2264 4) : \u00ac a > 4 :=\n", "sideBar": true, "firstProofLineNumber": 27, "lastProofLineNumber": 28, "textBefore": "-- Level name : Ungleichungen TBD\n\n-- namespace nat -- hide \n\nimport data.nat.basic -- hide\nimport tactic\nnamespace nat -- hide \n\n/-\nText, split\n-/\n\n/- Hint : Hint Title?\nHint teeeext.\n-/\n\n/-\nMore teeeeext (8)\n-/\n\n/- Theorem\nTBD\n-/\n\ntheorem not_sure (a : \u2115) (h : a \u2264 4) : \u00ac a > 4 :=\nbegin\n", "proof": "push_neg,\nexact h,", "proof_hint": "sorry", "textAfter": "\nend\n\nend nat -- hide", "height": 2, "editorText": "sorry", "lineOffset": 26, "name": "not_sure", "statement": "(a : \u2115) (h : a \u2264 4) : \u00ac a > 4"}, {"type": "lean", "content": "268", "hidden": true}]}, {"name": "269", "problemIndex": 7, "objects": [{"type": "lean", "content": "270", "hidden": true}, {"type": "lean", "content": "271", "hidden": true}, {"type": "lean", "content": "272", "hidden": false}, {"type": "lean", "content": "273", "hidden": true}, {"type": "text", "content": "274"}, {"type": "hint", "content": "275", "title": "276"}, {"type": "text", "content": "277"}, {"type": "theorem", "text": "278", "lean": "theorem no_small_mul_four : \u00ac\u2203 (n m : \u2115), m > 0 \u2227 n<4 \u2227 n = m*4 :=\n", "sideBar": true, "firstProofLineNumber": 27, "lastProofLineNumber": 34, "textBefore": "-- Level name : Ungleichungen TBD\n\n-- namespace nat -- hide \n\nimport data.nat.basic -- hide\nimport tactic\nnamespace nat -- hide \n\n/-\nText, split\n-/\n\n/- Hint : Hint Title?\nHint teeeext.\n-/\n\n/-\nMore teeeeext (8)\n-/\n\n/- Theorem\nTBD\n-/\n\ntheorem no_small_mul_four : \u00ac\u2203 (n m : \u2115), m > 0 \u2227 n<4 \u2227 n = m*4 :=\nbegin\n", "proof": "by_contra h_contr,\nobtain \u27e8n, m, hnm\u27e9 := h_contr,\ncases hnm with hm hrest,\ncases hrest with hn hnm,\nhave n_bigger_four : n \u2265 4,\n{rw hnm,\nlinarith,},\nlinarith,", "proof_hint": "sorry", "textAfter": "\nend\n\n\n/- Tactic : rw\n## Anleitung\nWenn `h` eine Aussage des Typs `X = Y` ist, dann wird\n`rw h,` alle `X` in der zu beweisenden Aussage durch\n`Y` austauschen.\nUm alle `Y` durch `X` zu ersetzten verwendet man `rw \u2190 h`.\n## Beispiel\nBei folgendem Zustand:\n```\nx : N\n\u22a2 succ (x + 0) = succ (x)\n```\nwird `rw add_zero,` das Ziel um\u00e4ndern zu `\u22a2 succ x = succ (x)`,\nund damit den Beweis abschlie\u00dfen.\n-/\nend nat -- hide", "height": 8, "editorText": "sorry", "lineOffset": 26, "name": "no_small_mul_four", "statement": "\u00ac\u2203 (n m : \u2115), m > 0 \u2227 n<4 \u2227 n = m*4"}, {"type": "tactic", "content": "279", "name": "rw", "sideBar": true}, {"type": "lean", "content": "280", "hidden": true}]}, {"name": "281", "problemIndex": 7, "objects": [{"type": "lean", "content": "282", "hidden": true}, {"type": "lean", "content": "283", "hidden": true}, {"type": "lean", "content": "284", "hidden": false}, {"type": "lean", "content": "285", "hidden": true}, {"type": "text", "content": "286"}, {"type": "hint", "content": "287", "title": "288"}, {"type": "text", "content": "289"}, {"type": "theorem", "text": "290", "lean": "theorem tobedet (n : \u2115) (hn : n \u2265 4) : \u00ac\u2203 (m : \u2115), m+n=3:=\n", "sideBar": true, "firstProofLineNumber": 26, "lastProofLineNumber": 32, "textBefore": "-- Level name : Ungleichungen TBD\n\n-- namespace nat -- hide \n\nimport data.nat.basic -- hide\nimport tactic\nnamespace nat -- hide \n\n/-\nGoal: introduce contradiction!\n-/\n\n/- Hint : Hint Title?\nHint teeeext.\n-/\n\n/-\nMore teeeeext (8)\n-/\n\n/- Theorem\nTBD\n-/\ntheorem tobedet (n : \u2115) (hn : n \u2265 4) : \u00ac\u2203 (m : \u2115), m+n=3:=\nbegin\n", "proof": "by_contra h_contr,\nobtain \u27e8m, hm\u27e9 := h_contr,\nhave h_2 : m + n \u2265 4,\n{linarith,},\nhave h_3 : \u00ac m + n \u2265 4,\n{linarith,},\ncontradiction,", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : rw\n## Anleitung\nWenn `h` eine Aussage des Typs `X = Y` ist, dann wird\n`rw h,` alle `X` in der zu beweisenden Aussage durch\n`Y` austauschen.\nUm alle `Y` durch `X` zu ersetzten verwendet man `rw \u2190 h`.\n## Beispiel\nBei folgendem Zustand:\n```\nx : N\n\u22a2 succ (x + 0) = succ (x)\n```\nwird `rw add_zero,` das Ziel um\u00e4ndern zu `\u22a2 succ x = succ (x)`,\nund damit den Beweis abschlie\u00dfen.\n-/\nend nat -- hide", "height": 7, "editorText": "sorry", "lineOffset": 25, "name": "tobedet", "statement": "(n : \u2115) (hn : n \u2265 4) : \u00ac\u2203 (m : \u2115), m+n=3"}, {"type": "tactic", "content": "291", "name": "rw", "sideBar": true}, {"type": "lean", "content": "292", "hidden": true}]}], "parents": [2]}, {"name": "293", "levels": [{"name": "294", "problemIndex": 7, "objects": [{"type": "lean", "content": "295", "hidden": true}, {"type": "lean", "content": "296", "hidden": true}, {"type": "lean", "content": "297", "hidden": true}, {"type": "lean", "content": "298", "hidden": true}, {"type": "text", "content": "299"}, {"type": "hint", "content": "300", "title": "301"}, {"type": "text", "content": "302"}, {"type": "theorem", "text": "303", "lean": "theorem exist_divisor_rest_gr (m n : \u2115) (hm : m > 0) : \u2203 q r : \u2115, n = m * q + r :=\n", "sideBar": true, "firstProofLineNumber": 26, "lastProofLineNumber": 34, "textBefore": "-- Level name : Existenz Divisor und Rest - unbeschr\u00e4nkt\n\n-- namespace nat -- hide \n\nimport data.nat.basic -- hide\nimport tactic -- hide\nnamespace nat -- hide\n\n/-\nUse needs to be introduced at latest here.\n-/\n\n/- Hint : Hint Title?\nHint teeeext.\n-/\n\n/-\nMore teeeeext (8)\n-/\n\n/- Theorem\nF\u00fcr nat\u00fcrliche Zahlen m,n mit $m>0$ gilt: Es gibt nat\u00fcrliche Zahlen q, r mit $n = m*q + r$\n-/\ntheorem exist_divisor_rest_gr (m n : \u2115) (hm : m > 0) : \u2203 q r : \u2115, n = m * q + r :=\nbegin\n", "proof": "  induction n with d hd,\n  { use [0, 0],\n    simp [hm], },\n  { by_cases hq : \u2203 q, d.succ = m*q,\n    { obtain \u27e8q, hq\u27e9 := hq,\n      use [q, 0],\n      simp [hq],},\n    { use [0, d.succ],\n      simp, } }", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : rw\n## Anleitung\nWenn `h` eine Aussage des Typs `X = Y` ist, dann wird\n`rw h,` alle `X` in der zu beweisenden Aussage durch\n`Y` austauschen.\nUm alle `Y` durch `X` zu ersetzten verwendet man `rw \u2190 h`.\n## Beispiel\nBei folgendem Zustand:\n```\nx : N\n\u22a2 succ (x + 0) = succ (x)\n```\nwird `rw add_zero,` das Ziel um\u00e4ndern zu `\u22a2 succ x = succ (x)`,\nund damit den Beweis abschlie\u00dfen.\n-/\n\nend nat -- hide", "height": 9, "editorText": "sorry", "lineOffset": 25, "name": "exist_divisor_rest_gr", "statement": "(m n : \u2115) (hm : m > 0) : \u2203 q r : \u2115, n = m * q + r"}, {"type": "tactic", "content": "304", "name": "rw", "sideBar": true}, {"type": "lean", "content": "305", "hidden": true}]}, {"name": "306", "problemIndex": 8, "objects": [{"type": "lean", "content": "307", "hidden": true}, {"type": "lean", "content": "308", "hidden": true}, {"type": "lean", "content": "309", "hidden": false}, {"type": "lean", "content": "310", "hidden": true}, {"type": "lean", "content": "311", "hidden": true}, {"type": "text", "content": "312"}, {"type": "hint", "content": "313", "title": "314"}, {"type": "text", "content": "315"}, {"type": "theorem", "text": "316", "lean": "theorem lemma_div (m d q r : \u2115) (hq' : \u00ac \u2203 (q':\u2115), d.succ=m*q') (hq : d = m*q+r) (hr : r < m): r+1<m :=\n", "sideBar": true, "firstProofLineNumber": 27, "lastProofLineNumber": 43, "textBefore": "-- Level name : Existenz Divisor und Rest\n\n-- namespace nat -- hide \n\nimport data.nat.basic -- hide\nimport tactic\nimport game.Division_mit_Rest.level_1 --hide\nnamespace nat -- hide \n\n/-\nText Text Text\n-/\n\n/- Hint : Hint Title?\nHint teeeext.\n-/\n\n/-\nMore teeeeext (8)\n-/\n\n/- Theorem\nF\u00fcr nat\u00fcrliche Zahlen m,n mit $m>0$ gilt: Es gibt nat\u00fcrliche Zahlen q, r mit $r < m$ und $n = m*q + r$\n-/\ntheorem lemma_div (m d q r : \u2115) (hq' : \u00ac \u2203 (q':\u2115), d.succ=m*q') (hq : d = m*q+r) (hr : r < m): r+1<m :=\nbegin\n", "proof": "  by_contra h_contr,\n  push_neg at h_contr,\n  have hr_succ_le_m : r + 1 \u2264 m,\n  { exact succ_le_of_lt hr, },\n  have hr1_m : r+1=m,\n  {exact le_antisymm hr_succ_le_m h_contr,}, \n  have d_mult_q : d.succ = m*(q+1),\n  {rw succ_eq_add_one,\n  rw hq,\n  rw add_assoc,\n  rw hr1_m,\n  rw mul_add,\n  simp,\n  },\n  have h_eq : \u2203 (q : \u2115), d.succ = m * q := \u27e8q+1, d_mult_q\u27e9,\n  contradiction,\n        ", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : rw\n## Anleitung\nWenn `h` eine Aussage des Typs `X = Y` ist, dann wird\n`rw h,` alle `X` in der zu beweisenden Aussage durch\n`Y` austauschen.\nUm alle `Y` durch `X` zu ersetzten verwendet man `rw \u2190 h`.\n## Beispiel\nBei folgendem Zustand:\n```\nx : N\n\u22a2 succ (x + 0) = succ (x)\n```\nwird `rw add_zero,` das Ziel um\u00e4ndern zu `\u22a2 succ x = succ (x)`,\nund damit den Beweis abschlie\u00dfen.\n-/\nend nat -- hide", "height": 17, "editorText": "sorry", "lineOffset": 26, "name": "lemma_div", "statement": "(m d q r : \u2115) (hq' : \u00ac \u2203 (q':\u2115), d.succ=m*q') (hq : d = m*q+r) (hr : r < m): r+1<m"}, {"type": "tactic", "content": "317", "name": "rw", "sideBar": true}, {"type": "lean", "content": "318", "hidden": true}]}, {"name": "319", "problemIndex": 8, "objects": [{"type": "lean", "content": "320", "hidden": true}, {"type": "lean", "content": "321", "hidden": true}, {"type": "lean", "content": "322", "hidden": false}, {"type": "lean", "content": "323", "hidden": true}, {"type": "lean", "content": "324", "hidden": true}, {"type": "text", "content": "325"}, {"type": "hint", "content": "326", "title": "327"}, {"type": "text", "content": "328"}, {"type": "theorem", "text": "329", "lean": "theorem exist_divisor_rest (m n : \u2115) (hm : m > 0) : \u2203 q r : \u2115, n = m * q + r \u2227 r < m :=\n", "sideBar": true, "firstProofLineNumber": 27, "lastProofLineNumber": 57, "textBefore": "-- Level name : Existenz Divisor und Rest\n\n-- namespace nat -- hide \n\nimport data.nat.basic -- hide\nimport tactic\nimport game.Division_mit_Rest.level_2 --hide\nnamespace nat -- hide \n\n/-\nText Text Text\n-/\n\n/- Hint : Hint Title?\nHint teeeext.\n-/\n\n/-\nMore teeeeext (8)\n-/\n\n/- Theorem\nF\u00fcr nat\u00fcrliche Zahlen m,n mit $m>0$ gilt: Es gibt nat\u00fcrliche Zahlen q, r mit $r < m$ und $n = m*q + r$\n-/\ntheorem exist_divisor_rest (m n : \u2115) (hm : m > 0) : \u2203 q r : \u2115, n = m * q + r \u2227 r < m :=\nbegin\n", "proof": "  induction n with d hd,\n  { -- Induktionsanfang\n    use [0, 0],\n    split,\n    { -- Zeige: 0=m*0+0\n      simp, },\n    { -- Zeige: 0 kleiner m\n      exact hm, }, },\n  { -- Induktionsschritt\n    by_cases hq2 : \u2203 q', d.succ = m*q',\n    { -- Fall m teilt d+1\n      obtain \u27e8q, hq\u27e9 := hq2,\n      use [q, 0],\n      split,\n      { -- Zeige: d+1=m*q+0\n        simp [hq],\n        },\n      { -- Zeige: r kleiner m\n        exact hm, }, },\n    { -- Fall m teilt d+1 nicht\n      obtain \u27e8q, r, \u27e8hq, hr\u27e9\u27e9 := hd,\n      use [q, r + 1],\n      split,\n      { -- Zeige: d+1 = m * q + (r + 1)\n        rw hq,\n        rw add_succ, },\n      { -- Zeige r kleiner m\n        apply lemma_div m d q r hq2 hq hr,\n        },\n    },\n  },", "proof_hint": "sorry", "textAfter": "\nend\n\n/- Tactic : rw\n## Anleitung\nWenn `h` eine Aussage des Typs `X = Y` ist, dann wird\n`rw h,` alle `X` in der zu beweisenden Aussage durch\n`Y` austauschen.\nUm alle `Y` durch `X` zu ersetzten verwendet man `rw \u2190 h`.\n## Beispiel\nBei folgendem Zustand:\n```\nx : N\n\u22a2 succ (x + 0) = succ (x)\n```\nwird `rw add_zero,` das Ziel um\u00e4ndern zu `\u22a2 succ x = succ (x)`,\nund damit den Beweis abschlie\u00dfen.\n-/\nend nat -- hide", "height": 31, "editorText": "sorry", "lineOffset": 26, "name": "exist_divisor_rest", "statement": "(m n : \u2115) (hm : m > 0) : \u2203 q r : \u2115, n = m * q + r \u2227 r < m"}, {"type": "tactic", "content": "330", "name": "rw", "sideBar": true}, {"type": "lean", "content": "331", "hidden": true}]}], "parents": [3]}], "texts": [["Die nat\u00fcrlichen Zahlen", "intro", "# Die nat\u00fcrlichen Zahlen\n## Worum geht es in diesem Spiel?\n### Mathematisch \nIn der Schule lernen wir die nat\u00fcrlichen Zahlen kennen und wir lernen, wie \nwir mit ihnen elementare Rechenoperationen durchf\u00fchren. Dabei wird aber nicht \nauf die formale Definition eingegangen.\n\nIn dieser Einheit m\u00f6chten wir die Definition der nat\u00fcrlichen Zahlen nach Peano\nbetrachten. Grob gesagt entstehen damit die nat\u00fcrlichen Zahlen aus der 0 zusammen \nmit Rekursion. \u00dcber die Rekursion kann dann die Addition, Multiplikation und \nPotenzierung definiert werden. F\u00fcr diese Rechenoperationen werden wir dann die \ngrundlegenden Eigenschaften wie Kommutativit\u00e4t und Assoziativit\u00e4t zeigen.\n\n### Technologisch\nWir werden die Programmiersprache \n<a href=\"https://leanprover-community.github.io/\" target=\"blank\">LEAN</a> kennenlernen.\nLEAN ist ein interaktiver Theorembeweiser. In einem Theorembeweiser kann man\neinen Beweis Schritt f\u00fcr Schritt (in Computersprache) eingeben. Dieser \u00fcberpr\u00fcft\ndann, ob der Beweis korrekt ist und kann an jeder Stelle des Beweises Feedback zum\naktuellen Stand des Beweises geben.\n\n\n## Eine kurze Anleitung.\nMit diesem Tool kannst du an dieser Einheit arbeiten. Die Einheit ist in die Kapitel\nPeano, Addition, Multiplikation und Potenzen eingeteilt. Bei der Addition und der \nMultiplikation gibt es zus\u00e4tzliche Kapitel mit Extra-Aufgaben. Jedes Kapitel hat \nmehrere Level. Am besten ist es, wenn du die Kapitel und Level der Reihe nach \nbearbeitest. Eine Ausnahme sind die Extra-Kapitel, die nicht erforderlich sind,\num mit dem n\u00e4chsten Kapitel weiterzumachen.\n\nIn jedem Level gibt es als Erstes einen Text, der den mathematischen Inhalt und die \nn\u00f6tigen LEAN-Anleitungen des Levels einf\u00fchrt. Darunter ist die zu l\u00f6sende Aufgabe:\nder Beweis eines Satzes, der in LEAN ausgef\u00fchrt werden soll.\n\nDein Fortschritt wird nicht automatisch gespeichert. Um beim n\u00e4chsten Mal dort\nweiterzumachen, wo du aufgeh\u00f6rt hast, solltest du vor dem Schlie\u00dfen dieses Fensters\nden \ud83d\udcbe Button \u00fcber dem Spielbaum klicken. Damit wird dein Spielstand in einer json-Datei gespeichert.\nDiese kannst du beim n\u00e4chsten Mal hochladen, indem du den \ud83d\udcdd Button klickst. \n\nViel Spa\u00df beim Coden!\n\n## Du bist mit dem Tool fertig - was nun?\n\nDieses Tool ist eine Anpassung der ersten Levels in dem \n<a href=\"https://www.ma.imperial.ac.uk/~buzzard/xena/natural_number_game/\" target=\"blank\">Natural Number Game</a>\nvon Kevin Buzzard. Du kannst dort noch mehr Levels l\u00f6sen und viele andere Befehle\nkennenlernen (In unserem Modul haben wir nur `rw` und `induction` verwendet). Die LEAN Version dort\nist etwas \u00e4lter und einige Dinge funktionieren leicht anders, am besten solltest\ndu also die ersten paar Levels wieder l\u00f6sen.\n", "Peano", "Die Peano Axiome", "-- namespace nat -- hide \n", "import mynat.definition -- hide\n", "namespace N -- hide\n", "Die nat\u00fcrlichen Zahlen k\u00f6nnen mit Peanos Axiomen eindeutig definiert werden. Die\nAxiome lauten wie folgt:\n- $A_1$: $0$ (in LEAN: `zero`) ist eine nat\u00fcrliche Zahl \n- $A_2$: Es gibt eine injektive Abbildung `succ`$: \\mathbb{N} \\to \\mathbb{N}$, die f\u00fcr jede nat\u00fcrliche Zahl ihren Nachfolger angibt.\n- $A_3$: $0$ ist nicht der Nachfolger einer nat\u00fcrlichen Zahl.\n- $A_4$: Das Prinzip der Induktion: Enth\u00e4lt eine Menge die $0$ und f\u00fcr jede enthaltene nat\u00fcrliche Zahl $n$ auch ihren Nachfolger `succ`$(n)$, so enth\u00e4lt sie alle nat\u00fcrlichen Zahlen.\n\nIn LEAN kann man die Anwendung der Abbildung `succ` auf `a` sowohl als `succ(a)` als auch \nals `a.succ` schreiben.\n", "Wir haben die Addition noch nicht definiert. Au\u00dferdem ist `succ`$(n)=n+1$ mit $1=$`succ`$(0)$ dann noch zu beweisen.\n", "Wieso brauchen wir hier die Abbildung `succ`, um den Nachfolger einer Zahl $n$ zu beschreiben, anstatt den Ausdruck n+1 zu verwenden?", "Aus diesen Axiomen werden wir alles herleiten und beweisen, was wir in dieser Einheit\nvorhaben. In diesem Level werden wir folgende Aussage zur Funktion `succ` zeigen: F\u00fcr die nat\u00fcrlichen Zahlen a und b gilt: falls `succ(a)=b` dann `succ(succ(a))=succ(b)`.\n\nDiese Aussage kann man direkt zeigen, indem man die gegebene Hypothese `succ(a)=b` in die\nzu zeigende Aussage `succ(succ(a))=succ(b)` einsetzt und somit `succ(b)=succ(b)` erh\u00e4lt.\n\nWir schauen uns nun an, wie das in LEAN funktioniert. Wir werden mit der Klasse\nN arbeiten, die genau nach den Axiomen von Peano definiert ist.\n", "`inductive N` \u2192 $A_4$ <br>\n`| zero : N` \u2192 $A_1$ <br>\n`| succ (n : N) : N` \u2192 $A_2$ <br>\n`lemma succ_inj {m n : N} (h : succ m = succ n) : m = n := by cases h; refl` \u2192 $A_2$ <br>\n`lemma zero_ne_succ (m : N) : (zero : N) \u2260 succ m := \u03bb h, by cases h` \u2192 $A_3$\n", "Klicke hier, um die Definition der nat\u00fcrlichen Zahlen in LEAN zu sehen. Du musst diesen Code nicht zu 100% verstehen.", "Als Erstes muss man das Lemma definieren, das man beweisen m\u00f6chte. Dies besteht aus drei \nTeilen.\n- Name: Der Name kann beliebig gew\u00e4hlt werden, ist im besten Fall aber eine gute \nBeschreibung des Lemmas. Hier kann man zum Beispiel \u201csucc_succ\u201d w\u00e4hlen, um anzudeuten, \ndass es um die Zweifachanwendung der Abbildung `succ` geht.\n- Voraussetzungen: Diese stehen zwischen dem Namen und dem Doppelpunkt. In diesem Fall\nsind das, dass a und b nat\u00fcrliche Zahlen sind und die Aussage h, dass `succ(a)=b`.\n- Folgerung: Diese steht zwischen dem Doppelpunkt und dem Definitionszeichen. In diesem\nFall also, `succ(succ(a))=b`.\n\nDer Beweis folgt zwischen dem `begin` und dem `end`. Zu Beginn der Bearbeitung steht im\nBeweis immer `sorry`. Dies ist ein Keyword, was so viel bedeutet wie: \"Hier fehlt ein\nTeil des Beweises\". Du kannst dieses Keyword verwenden, wenn ein Beweis \u00fcberpr\u00fcft werden\nsoll, bei dem dir noch ein Teil fehlt. LEAN wird best\u00e4tigen, dass der Beweis stimmt, aber\nmit dem warning \"uses `sorry`\" darauf hinweisen, dass noch etwas zu tun ist. L\u00f6sche als\nErstes das `sorry`, um mit dem Beweis zu starten.\n\nWir haben oben bereits beschrieben, wie der Beweis mathematisch funktioniert. Wie \n\u00fcbertragen wir die Idee in LEAN? Dazu gibt es den `rw` (rewrite) Befehl. Wenn `h` eine\nAussage ist (z.B. $a=b$), dann bewirkt `rw h,`, dass LEAN die Aussage `h` in der zu \nzeigenden Aussage einsetzt (im Beispiel w\u00fcrde also in der zu zeigenden Aussage jedes $a$\nmit einem $b$ ersetzt werden). Probiere also den Befehl `rw h,` aus. Das Komma am Ende \njedes LEAN-Befehls ist sehr wichtig. Wenn du Fehlermeldungen bekommst, die du nicht\nverstehst, \u00fcberpr\u00fcfe deinen Code auf fehlende Kommata.\n\nDie rechte Spalte:\nHier gibt LEAN dynamisches Feedback. Bis auf die letzte Zeile steht hier immer was \ngegeben ist, in diesem Fall zum Beispiel, dass a und b nat\u00fcrliche Zahlen sind und die\nAussage `h`. In der letzten Zeile, nach dem `\u22a2` Symbol, steht immer das aktuelle Ziel, \nalso das, was gerade zu  zeigen ist. Wenn man am Anfang des Beweises steht, ist das \nnoch die ganze Aussage des Lemmas. Nachdem man `rw h,` eingibt, sieht man, dass sich \nder Zustand \u00e4ndert. In diesem Fall kommt die Nachricht `Proof complete!`, die uns \nangibt, dass wir fertig sind. In l\u00e4ngeren Aufgaben w\u00fcrde hier das neue Ziel stehen.\n", "Falls `succ`$(a) = b$, dann `succ`$($`succ`$(a)) = $`succ`$(b)$\n", "## Anleitung\nWenn `h` eine Aussage des Typs `X = Y` ist, dann wird\n`rw h,` alle `X` in der zu beweisenden Aussage durch\n`Y` austauschen.\nUm alle `Y` durch `X` zu ersetzten verwendet man `rw \u2190 h`.\n## Beispiel\nBei folgendem Zustand:\n```\nx : N\n\u22a2 succ (x + 0) = succ (x)\n```\nwird `rw add_zero,` das Ziel um\u00e4ndern zu `\u22a2 succ x = succ (x)`,\nund damit den Beweis abschlie\u00dfen.\n", "end N -- hide", "Die Peano Axiome - Teil 2", "-- namespace nat -- hide \n", "import mynat.definition -- hide\n", "import game.Peano.level_1 --hide\n", "namespace N -- hide\n", "In diesem Level passiert nicht viel. Es dient eher zur \u00dcbung von dem Gelernten in\nLevel 1.\n\nVielleicht hast du gemerkt, dass es eine linke Spalte gibt. Hier kannst du alle\nTools finden, die du zum Beweisen brauchst. Das sind einerseits die Befehle (wie\nz.B. `rw`), die in LEAN Tactics hei\u00dfen. Andererseits sind das die Axiome und Aussagen,\ndie wir bereits eingef\u00fchrt/bewiesen haben. Diese sind in der Kategorie Theorem\nstatements. Umso weiter du bist, umso mehr Inhalt wirst du hier finden.\n\nWir werden aber auch die Gelegenheit nutzen, um uns den `rw` Befehl nochmal\nanzuschauen. Wir haben gesehen, dass f\u00fcr die Aussage `h: a = b` der Befehl\n`rw h,` in der zu zeigenden Aussage jedes `a` durch ein `b` ersetzt. Aber wie\nkann man jedes `b` durch ein `a` ersetzen? Dazu verwendet man den Befehl\n`rw \u2190 h,`. Der Pfeil steht sozusagen daf\u00fcr, dass LEAN die Aussage h von rechts\nnach links lesen soll. Du kannst den Pfeil mit \\ l (backslash + klein L)\nschreiben.\n\nDu kannst das untenstehende Lemma \u00e4hnlich wie Level 1 l\u00f6sen, aber erkennst du\nauch einen weiteren Weg?\n", "Falls `succ`$(a) = b$ und `succ`$(b)= c$, dann `succ`$($`succ`$(a)) = c$\n", "end N -- hide\n", "In der zu zeigenden Aussage kommt der Term `c` vor, der auch Teil der Aussage\n`g` ist. Du kannst also mit `rw \u2190 g,` das `c` in der Aussage ersetzen.\n", "Brauchst du Hilfe, um einen zweiten Weg zu finden?", "Die Peano Axiome - Teil 2", "-- namespace nat -- hide \n", "import mynat.definition -- hide\n", "import game.Peano.level_2 --hide\n", "namespace N -- hide\n", "\n", "Falls `succ`$(a) = b$ und `succ`$(b)= c$, dann `succ`$($`succ`$(a)) = c$\n", "end N -- hide\n", "In der zu zeigenden Aussage kommt der Term `c` vor, der auch Teil der Aussage\n`g` ist. Du kannst also mit `rw \u2190 g,` das `c` in der Aussage ersetzen.\n", "Brauchst du Hilfe, um einen zweiten Weg zu finden?", "Addition", "TBD", "-- namespace nat -- hide \n", "import mynat.add -- hide\n", "import game.Peano.level_3 -- hide\n", "namespace N -- hide\n", "Hier: SPEZIFIZIERUNG!\n", "Hint teeeext.\n", "Hint Title?", "More teeeeext (8)\n", "TBD\n", "## Anleitung\nWenn `h` eine Aussage des Typs `X = Y` ist, dann wird\n`rw h,` alle `X` in der zu beweisenden Aussage durch\n`Y` austauschen.\nUm alle `Y` durch `X` zu ersetzten verwendet man `rw \u2190 h`.\n## Beispiel\nBei folgendem Zustand:\n```\nx : N\n\u22a2 succ (x + 0) = succ (x)\n```\nwird `rw add_zero,` das Ziel um\u00e4ndern zu `\u22a2 succ x = succ (x)`,\nund damit den Beweis abschlie\u00dfen.\n", "end N -- hide", "Die Addition", "import mynat.add -- hide\n", "import game.Addition.level_1 --hide\n", "namespace N -- hide\n", "a + 0 = a\n", "a + succ(b) = succ(a + b)\n", "Man kann die Addition zweier nat\u00fcrlichen Zahlen rekursiv anhand der Peano-Axiome \ndefinieren.\n- F\u00fcr $a \\in \\mathbb{N}$ sei $a+0=a$\n- F\u00fcr $a,d \\in \\mathbb{N}$ sei $a+$`succ`$(d) = $`succ`$(a+d)$\n\nNach dem Prinzip der Induktion ist dann die Addition f\u00fcr alle Paare von nat\u00fcrlichen\nZahlen definiert.\n\nDie beiden Aussagen, die die Addition definieren, sind in LEAN implementiert und \nhaben jeweils den Namen `add_zero` und `add_succ`. Auch diese Aussagen k\u00f6nnen mit\ndem Befehl `rw` verwendet werden. `rw add_zero,` wandelt die Aussage `b+zero` in `b`\num.\n", "Definition: <br>\n`def add : N \u2192 N \u2192 N` <br>\n`| m 0 := m` <br>\n`| m (succ n) := succ (add m n)` <br>\n\nDen beiden definierenden Eigenschaften wird ein Namen gegeben: <br>\n`lemma add_zero (m : N) : m + zero = m := rfl` <br>\n`lemma add_succ (m n : N) : m + succ n = succ (m + n) := rfl`\n", "Klicke hier, um die Definition der Addition der nat\u00fcrlichen Zahlen in LEAN zu sehen. Du musst diesen Code nicht zu 100% verstehen.", "In diesem Level werden wir zeigen, dass Addition mit dem Nachfolger von $0$ (den\nwir noch nicht formal als $1$ eingef\u00fchrt haben), gleich dem Nachfolger der Zahl ist.\n", "$a+$`succ`$(0)=$`succ`$(a)$\n", "end N -- hide", "Die nat\u00fcrliche Zahl 1", "import mynat.add -- hide\n", "import game.Addition.level_2 --hide\n", "namespace N -- hide\n", "one = succ(zero)\n", "TODO: simp!!\nAus praktischen Gr\u00fcnden m\u00f6chten wir nun dem Nachfolger von $0$ einen Namen\ngeben. Diese Zahl nennen wir $1$. Die Aussage `one = succ(zero)` hei\u00dft in\nLEAN `one_eq_succ_zero`.\n", "`def one : N := succ zero` <br>\n`theorem one_eq_succ_zero : one = succ zero := rfl`\n", "Klicke hier, um die Definition der Nummer $1$ in LEAN zu sehen. Du musst diesen Code nicht zu 100% verstehen.", "Nun k\u00f6nnen wir zeigen, dass der Nachfolger von $a$ gleich $a+1$ ist. \n", "`succ`$(a) = a + 1$\n", "end N -- hide", "Addition mit 0 - von links", "import mynat.add -- hide\n", "import game.Addition.level_3 --hide\n", "namespace N -- hide\n", "## Anleitung\nfalls `n : N` gegeben ist, dann startet `induction n with d hd`\neinen Induktionsbeweis \u00fcber `n` der zu beweisenden Aussage. `d` wird \nder Name der Variable im Induktionsschritt sein, und `hd` ist die Aussage\nder Induktionsvoraussetzung.\n## Beispiel\nBei folgendem Zustand:\n```\nn : N\n\u22a2 2 * n = n + n\n```\ndann wird `induction n with d hd` zwei neue Ziele \u00f6ffnen:\n```\n\u22a2 2 * 0 = 0 + 0\n```\nund\n```\nd : mynat,\nhd : 2 * d = d + d\n\u22a2 2 * succ d = succ d + succ d\n```\n", "Nach Definition der Addition gilt: $a+0=a$. Wir haben aber noch nicht bewiesen,\ndass die Addition kommutativ ist. Es ist also noch nicht bewiesen, dass auch\n$0+a=a$ gilt.\n\nDies werden wir \u00fcber Induktion zeigen. Dazu lernen wir den `induction` Befehl in\nLEAN. Um einen Induktionsbeweis zu starten, m\u00fcssen wir `induction a with d hd,`\naufrufen. Dabei ist das $a$ die Variable, \u00fcber die induziert werden soll, $d$\nwird der Name der Variable im Induktionsschritt sein, und `hd` ist die Aussage\nder Induktionsvoraussetzung.\n\nNachdem du den Befehl `induction a with d hd,` eingibst, wirst du in der rechten\nSpalte sehen, dass du zwei Beweisziele hast: den Induktionsanfang und die \nInduktionsvoraussetzung. Um den Beweis \u00fcbersichtlicher zu f\u00fchren, kannst du\ndie zwei Teile mit geschweiften Klammern umgeben. Dein Beweis hat dann die Form: <br>\n`begin` <br>\n  `induction a with d hd,` <br>\n  `{},` <br>\n  `{},` <br>\n`end` <br>\nInnerhalb der geschweiften Klammern kannst du dann jeweils den Induktionsanfang und\nden Induktionsschritt zeigen.\n\nZu diesem Beweis gibt es <a href=\"https://go.upb.de/lean_2_3\" target=\"blank\">hier</a> ein Aufgabenblatt.\n", "$0+a=a$\n", "end N -- hide", "Assoziativit\u00e4t der Addition", "import mynat.add -- hide\n", "import game.Addition.level_4 --hide\n", "namespace N -- hide\n", "Nun werden wir die Assoziativit\u00e4t der Addition der nat\u00fcrlichen\nZahlen zeigen. Das bedeutet $(a + b) + c = a + (b + c)$. \n", "Wir haben die Addition mit Rekursion auf die rechte Variable definiert,\nes ist also sinnvoll bei dem Induktionsbeweis \u00fcber die Variable\n$c$ zu induzieren.\n", "\u00dcber welcher der drei Variablen ist ein Induktionsbeweis am sinnvollsten?", "Noch eine Bemerkung: LEAN ist linksassoziativ. Das bedeutet, dass f\u00fcr LEAN\n$a+b+b$ das gleiche wie $(a+b)+c$ ist.\n\nZu diesem Beweis gibt es <a href=\"https://go.upb.de/lean_2_4\" target=\"blank\">hier</a> ein Aufgabenblatt.\n", "$(a + b) + c = a + (b + c)$\n", "end N -- hide", "Addition mit dem Nachfolger - von links", "import mynat.add -- hide\n", "import game.Addition.level_5 --hide\n", "import tactic\n", "namespace N -- hide\n", "Genauso wie wir aus $a+0=a$ nicht direkt $0+a=a$ folgern k\u00f6nnten, k\u00f6nnen wir\naus $b + $`succ`$(a) =$ `succ`$(b+a)$ nicht `succ`$(a)+b =$ `succ`$(a+b)$\nfolgern. Wir haben n\u00e4mlich noch nicht bewiesen, dass die Addition kommutativ ist.\n", "`succ`$(a)+b = $`succ`$(a+b)$\n", "end N -- hide", "Kommutativit\u00e4t der Addition", "import mynat.add -- hide\n", "import game.Addition.level_6 --hide\n", "namespace N -- hide\n", "Endlich k\u00f6nnen wir zeigen, dass die Addition kommutativ ist!\n\nZu diesem Beweis gibt es <a href=\"https://go.upb.de/lean_2_6\" target=\"blank\">hier</a> ein Aufgabenblatt.\n", "a+b=b+a\n", "end N -- hide", "Kommutativit\u00e4t der rechten Summanden", "import mynat.add -- hide\n", "import game.Addition.level_7 --hide\n", "namespace N -- hide\n", "Das Ziel dieses Levels ist $a+b+c=a+c+b$. Das sieht vielleicht erstmal danach aus,\ndass du nur `add_comm,` anwenden muss. Aber LEAN ist links-assoziativ. Das bedeutet,\ndass diese Aussage mit Klammern so geschrieben werden kann: $(a+b)+c=(a+c)+b$. Um\ndieses Lemma zu zeigen, wirst du also auch die Assoziativit\u00e4t verwenden. Dieses\nLemma wird dir in zuk\u00fcnftigen Beweisen etwas Schreibarbeit sparen.\n\nNoch eine Bemerkung: manchmal gibt es mehr als eine Stelle, an der `rw` etwas\nanstellen kann. Wenn du nichts Weiteres spezifizierst, wird LEAN die erste dieser\nStellen heraussuchen. Wenn du zum Beispiel in diesem Level damit anfangen m\u00f6chtest,\ndass du auf der rechten Seite $a+c+b$ zu $a+(c+b)$ umschreibst, wird das nicht mit\ndem Befehl `rw add_assoc,` klappen. Dies wird n\u00e4mlich in der linken Seite der Gleichung\ndie Assoziativit\u00e4t ausnutzen. Du kannst LEAN konkret angeben an welcher Stelle du die\n\u00c4nderung m\u00f6chtest, in diesem Fall: `rw add_assoc a c b,`.\n", "$a+b+c=a+c+b$\n", "end N -- hide", "Kommutativit\u00e4t der rechten Summanden", "import data.nat.basic -- hide\n", "import tactic -- hide\n", "namespace nat -- hide\n", "Das Ziel dieses Levels ist $a+b+c=a+c+b$. Das sieht vielleicht erstmal danach aus,\ndass du nur `add_comm,` anwenden muss. Aber LEAN ist links-assoziativ. Das bedeutet,\ndass diese Aussage mit Klammern so geschrieben werden kann: $(a+b)+c=(a+c)+b$. Um\ndieses Lemma zu zeigen, wirst du also auch die Assoziativit\u00e4t verwenden. Dieses\nLemma wird dir in zuk\u00fcnftigen Beweisen etwas Schreibarbeit sparen.\n\nNoch eine Bemerkung: manchmal gibt es mehr als eine Stelle, an der `rw` etwas\nanstellen kann. Wenn du nichts Weiteres spezifizierst, wird LEAN die erste dieser\nStellen heraussuchen. Wenn du zum Beispiel in diesem Level damit anfangen m\u00f6chtest,\ndass du auf der rechten Seite $a+c+b$ zu $a+(c+b)$ umschreibst, wird das nicht mit\ndem Befehl `rw add_assoc,` klappen. Dies wird n\u00e4mlich in der linken Seite der Gleichung\ndie Assoziativit\u00e4t ausnutzen. Du kannst LEAN konkret angeben an welcher Stelle du die\n\u00c4nderung m\u00f6chtest, in diesem Fall: `rw add_assoc a c b,`.\n", "$a+b+c=a+c+b$\n", "end nat -- hide", "TBD", "-- namespace nat -- hide \n", "import data.nat.basic -- hide\n", "import tactic -- hide\n", "namespace nat -- hide\n", "Use needs to be introduced at latest here.\n", "Hint teeeext.\n", "Hint Title?", "More teeeeext (8)\n", "F\u00fcr nat\u00fcrliche Zahlen m,n mit $m>0$ gilt: Es gibt nat\u00fcrliche Zahlen q, r mit $n = m*q + r$\n", "## Anleitung\nWenn `h` eine Aussage des Typs `X = Y` ist, dann wird\n`rw h,` alle `X` in der zu beweisenden Aussage durch\n`Y` austauschen.\nUm alle `Y` durch `X` zu ersetzten verwendet man `rw \u2190 h`.\n## Beispiel\nBei folgendem Zustand:\n```\nx : N\n\u22a2 succ (x + 0) = succ (x)\n```\nwird `rw add_zero,` das Ziel um\u00e4ndern zu `\u22a2 succ x = succ (x)`,\nund damit den Beweis abschlie\u00dfen.\n", "end nat -- hide", "Kommutativit\u00e4t der rechten Summanden", "import data.nat.basic -- hide\n", "import tactic\n", "namespace nat -- hide\n", "\n", "$a+b+c=a+c+b$\n", "end nat -- hide", "TBD", "-- namespace nat -- hide \n", "import data.nat.basic -- hide\n", "import tactic -- hide\n", "namespace nat -- hide\n", "Use needs to be introduced at latest here.\n", "Hint teeeext.\n", "Hint Title?", "More teeeeext (8)\n", "F\u00fcr nat\u00fcrliche Zahlen m,n mit $m>0$ gilt: Es gibt nat\u00fcrliche Zahlen q, r mit $n = m*q + r$\n", "## Anleitung\nWenn `h` eine Aussage des Typs `X = Y` ist, dann wird\n`rw h,` alle `X` in der zu beweisenden Aussage durch\n`Y` austauschen.\nUm alle `Y` durch `X` zu ersetzten verwendet man `rw \u2190 h`.\n## Beispiel\nBei folgendem Zustand:\n```\nx : N\n\u22a2 succ (x + 0) = succ (x)\n```\nwird `rw add_zero,` das Ziel um\u00e4ndern zu `\u22a2 succ x = succ (x)`,\nund damit den Beweis abschlie\u00dfen.\n", "end nat -- hide", "TBD", "-- namespace nat -- hide \n", "import data.nat.basic -- hide\n", "import tactic\n", "namespace nat -- hide\n", "Use needs to be introduced at latest here.\n", "Hint teeeext.\n", "Hint Title?", "More teeeeext (8)\n", "F\u00fcr nat\u00fcrliche Zahlen m,n mit $m>0$ gilt: Es gibt nat\u00fcrliche Zahlen q, r mit $n = m*q + r$\n", "## Anleitung\nWenn `h` eine Aussage des Typs `X = Y` ist, dann wird\n`rw h,` alle `X` in der zu beweisenden Aussage durch\n`Y` austauschen.\nUm alle `Y` durch `X` zu ersetzten verwendet man `rw \u2190 h`.\n## Beispiel\nBei folgendem Zustand:\n```\nx : N\n\u22a2 succ (x + 0) = succ (x)\n```\nwird `rw add_zero,` das Ziel um\u00e4ndern zu `\u22a2 succ x = succ (x)`,\nund damit den Beweis abschlie\u00dfen.\n", "end nat -- hide", "Multiplikation", "Die Multiplikation", "import mynat.mul -- hide\n", "import game.Addition.level_8 --hide\n", "namespace N -- hide\n", "a * 0 = 0\n", "a * succ(b) = a*d+a\n", "Man kann auch die Multiplikation zweier nat\u00fcrlichen Zahlen rekursiv anhand der \nPeano-Axiome definieren.\n- F\u00fcr $a \\in \\mathbb{N}$ sei $a*0=0$\n- F\u00fcr $a,d \\in \\mathbb{N}$ sei $a* $`succ`$(d) = a*d+a$\n\nNach dem Prinzip der Induktion ist dann die Multiplikation f\u00fcr alle Paare von\nnat\u00fcrlichen Zahlen definiert.\n\nDie beiden Aussagen, die die Multiplikation definieren, sind in LEAN implementiert und \nhaben jeweils den Namen `mul_zero` und `mul_succ`.\n", "Definition: <br>\n`def mul : N \u2192 N \u2192 N` <br>\n`| a zero := zero` <br>\n`| a (succ d) := mul a d + a` <br>\n\nDen beiden definierenden Eigenschaften wird ein Namen gegeben: <br>\n`lemma mul_zero (a : N) : a * zero = zero := rfl` <br>\n`lemma mul_succ (a d : N) : a * (succ d) = a * d + a := rfl`\n", "Klicke hier, um die Definition der Multiplikation der nat\u00fcrlichen Zahlen in LEAN zu sehen. Du musst diesen Code nicht zu 100% verstehen.", "In diesem Level werden wir zeigen, dass auch die Multiplikation mit $0$ von links $0$ ergibt.\nWir haben die Kommutativit\u00e4t der Multiplikation noch nicht gezeigt.\n", "$0*a=0$\n", "end N -- hide", "Multiplikation mit dem Nachfolger - von links", "import mynat.mul -- hide\n", "import game.Multiplikation.level_1 --hide\n", "namespace N -- hide\n", "## Anleitung\nfalls du in der zu beweisenden Aussage einen Befehl (z.B. `rw add_zero,`) mehrmals\nanwenden kannst, dann wird `{repeat {\u2b1d,},` den Befehl so oft ausf\u00fchren, bis es\nkeine Instanz mehr gibt, an der der Befehl ausgef\u00fchrt werden kann.\n## Beispiel\nBei folgendem Zustand:\n```\na b : N\n\u22a2 a + zero + b = a + (b + zero)\n```\nwird `{repeat {rw add_zero,},` zweimal `add_zero` anwenden und\nsomit das Ziel zu `\u22a2 a + b = a + b ` umformen und damit\nl\u00f6sen.\n", "Manchmal m\u00f6chtest du einen Befehl mehrmals hintereinander ausf\u00fchren. Wenn du dir\nzum Beispiel den Induktionsanfang dieses Levels anschaust, musst du zeigen, dass\n`a.succ * zero = a * zero + zero`, du k\u00f6nntest damit anfangen, \u00fcberall wo mit\n$0$ multipliziert wird `rw mul_zero,` anzuwenden. Anstatt den Befehl zweimal\nauszuschreiben, kannst du `{repeat {rw mul_zero,},` anwenden. Dann wird LEAN den\nBefehl `rw mul_zero,` so oft ausf\u00fchren, bis es keine Instanz der Form `a+zero` gibt.\n", "`succ`$(a) * b = a * b + b$\n", "end N -- hide", "Kommutativit\u00e4t der Multiplikation", "import mynat.mul -- hide\n", "import game.Multiplikation.level_2 -- hide\n", "namespace N -- hide\n", "Die Ergebnisse aus Level 1 und 2 sind genug, um die Kommutativit\u00e4t zu zeigen!\n", "a * b = b * a\n", "end N -- hide\n", "Wenn du dir den Beweis der Kommutativit\u00e4t der Addition anschaust und dort\ndas \u00fcberall \"add\" mit \"mul\" ersetzt, hast du einen g\u00fcltigen Beweis f\u00fcr\ndie Kommutativit\u00e4t der Multiplikation!\n", "Kommen dir die Schritte in diesem Beweis bekannt vor?", "Das Distributivgesetz", "import mynat.mul -- hide\n", "import game.Multiplikation.level_3 -- hide\n", "namespace N -- hide\n", "Das Distributivgesetz gibt uns an, wie wir mit Ausdr\u00fccken umgehen k\u00f6nnen, in denen\nAddition und Multiplikation vorkommen.\n", "$c * (a + b) = c * a + c * b$\n", "end N -- hide", "Assoziativit\u00e4t der Multiplikation", "import mynat.mul -- hide\n", "import game.Multiplikation.level_4 -- hide\n", "namespace N -- hide\n", "\n\n\n", "$(a * b) * c = a * (b * c)$\n", "end N -- hide\n", "Nein, f\u00fcr diesen Beweis brauchst du n\u00e4mlich das Distributivgesetz. Das kommt daher, dass die \nDefinition der Multiplikation von der Addition abh\u00e4ngt (`a*succ(d)=a*d+a`).\n", "Kannst du auch bei der Assoziativit\u00e4t den Beweis aus der Addition einfach \u00fcbernehmen?", "TBD", "-- namespace nat -- hide \n", "import data.nat.basic -- hide\n", "namespace nat -- hide\n", "Use needs to be introduced at latest here.\n", "Hint teeeext.\n", "Hint Title?", "More teeeeext (8)\n", "F\u00fcr nat\u00fcrliche Zahlen m,n mit $m>0$ gilt: Es gibt nat\u00fcrliche Zahlen q, r mit $n = m*q + r$\n", "## Anleitung\nWenn `h` eine Aussage des Typs `X = Y` ist, dann wird\n`rw h,` alle `X` in der zu beweisenden Aussage durch\n`Y` austauschen.\nUm alle `Y` durch `X` zu ersetzten verwendet man `rw \u2190 h`.\n## Beispiel\nBei folgendem Zustand:\n```\nx : N\n\u22a2 succ (x + 0) = succ (x)\n```\nwird `rw add_zero,` das Ziel um\u00e4ndern zu `\u22a2 succ x = succ (x)`,\nund damit den Beweis abschlie\u00dfen.\n", "end nat -- hide", "Ungleichungen", "Ungleichungen TBD", "-- namespace nat -- hide \n", "import data.nat.basic -- hide\n", "import tactic -- hide\n", "namespace nat -- hide \n", "Hier wird zum ersten Mal use benutzt!!\n", "Hint teeeext.\n", "Hint Title?", "More teeeeext (8)\n", "TBD\n", "## Anleitung\nWenn `h` eine Aussage des Typs `X = Y` ist, dann wird\n`rw h,` alle `X` in der zu beweisenden Aussage durch\n`Y` austauschen.\nUm alle `Y` durch `X` zu ersetzten verwendet man `rw \u2190 h`.\n## Beispiel\nBei folgendem Zustand:\n```\nx : N\n\u22a2 succ (x + 0) = succ (x)\n```\nwird `rw add_zero,` das Ziel um\u00e4ndern zu `\u22a2 succ x = succ (x)`,\nund damit den Beweis abschlie\u00dfen.\n", "end nat -- hide", "Ungleichungen TBD", "-- namespace nat -- hide \n", "import data.nat.basic -- hide\n", "import tactic\n", "namespace nat -- hide \n", "Text, use mit mehreren Argumenten, linearith!\n", "Hint teeeext.\n", "Hint Title?", "More teeeeext (8)\n", "TBD\n", "## Anleitung\nWenn `h` eine Aussage des Typs `X = Y` ist, dann wird\n`rw h,` alle `X` in der zu beweisenden Aussage durch\n`Y` austauschen.\nUm alle `Y` durch `X` zu ersetzten verwendet man `rw \u2190 h`.\n## Beispiel\nBei folgendem Zustand:\n```\nx : N\n\u22a2 succ (x + 0) = succ (x)\n```\nwird `rw add_zero,` das Ziel um\u00e4ndern zu `\u22a2 succ x = succ (x)`,\nund damit den Beweis abschlie\u00dfen.\n", "end nat -- hide", "Ungleichungen TBD", "-- namespace nat -- hide \n", "import data.nat.basic -- hide\n", "import tactic\n", "namespace nat -- hide \n", "Text, split\n", "Hint teeeext.\n", "Hint Title?", "More teeeeext (8)\n", "TBD\n", "## Anleitung\nWenn `h` eine Aussage des Typs `X = Y` ist, dann wird\n`rw h,` alle `X` in der zu beweisenden Aussage durch\n`Y` austauschen.\nUm alle `Y` durch `X` zu ersetzten verwendet man `rw \u2190 h`.\n## Beispiel\nBei folgendem Zustand:\n```\nx : N\n\u22a2 succ (x + 0) = succ (x)\n```\nwird `rw add_zero,` das Ziel um\u00e4ndern zu `\u22a2 succ x = succ (x)`,\nund damit den Beweis abschlie\u00dfen.\n", "end nat -- hide", "Ungleichungen TBD", "-- namespace nat -- hide \n", "import data.nat.basic -- hide\n", "import tactic\n", "namespace nat -- hide \n", "Text, split\n", "Hint teeeext.\n", "Hint Title?", "More teeeeext (8)\n", "TBD\n", "end nat -- hide", "Ungleichungen TBD", "-- namespace nat -- hide \n", "import data.nat.basic -- hide\n", "import tactic\n", "namespace nat -- hide \n", "Text, split\n", "Hint teeeext.\n", "Hint Title?", "More teeeeext (8)\n", "TBD\n", "## Anleitung\nWenn `h` eine Aussage des Typs `X = Y` ist, dann wird\n`rw h,` alle `X` in der zu beweisenden Aussage durch\n`Y` austauschen.\nUm alle `Y` durch `X` zu ersetzten verwendet man `rw \u2190 h`.\n## Beispiel\nBei folgendem Zustand:\n```\nx : N\n\u22a2 succ (x + 0) = succ (x)\n```\nwird `rw add_zero,` das Ziel um\u00e4ndern zu `\u22a2 succ x = succ (x)`,\nund damit den Beweis abschlie\u00dfen.\n", "end nat -- hide", "Ungleichungen TBD", "-- namespace nat -- hide \n", "import data.nat.basic -- hide\n", "import tactic\n", "namespace nat -- hide \n", "Goal: introduce contradiction!\n", "Hint teeeext.\n", "Hint Title?", "More teeeeext (8)\n", "TBD\n", "## Anleitung\nWenn `h` eine Aussage des Typs `X = Y` ist, dann wird\n`rw h,` alle `X` in der zu beweisenden Aussage durch\n`Y` austauschen.\nUm alle `Y` durch `X` zu ersetzten verwendet man `rw \u2190 h`.\n## Beispiel\nBei folgendem Zustand:\n```\nx : N\n\u22a2 succ (x + 0) = succ (x)\n```\nwird `rw add_zero,` das Ziel um\u00e4ndern zu `\u22a2 succ x = succ (x)`,\nund damit den Beweis abschlie\u00dfen.\n", "end nat -- hide", "Division mit Rest", "Existenz Divisor und Rest - unbeschr\u00e4nkt", "-- namespace nat -- hide \n", "import data.nat.basic -- hide\n", "import tactic -- hide\n", "namespace nat -- hide\n", "Use needs to be introduced at latest here.\n", "Hint teeeext.\n", "Hint Title?", "More teeeeext (8)\n", "F\u00fcr nat\u00fcrliche Zahlen m,n mit $m>0$ gilt: Es gibt nat\u00fcrliche Zahlen q, r mit $n = m*q + r$\n", "## Anleitung\nWenn `h` eine Aussage des Typs `X = Y` ist, dann wird\n`rw h,` alle `X` in der zu beweisenden Aussage durch\n`Y` austauschen.\nUm alle `Y` durch `X` zu ersetzten verwendet man `rw \u2190 h`.\n## Beispiel\nBei folgendem Zustand:\n```\nx : N\n\u22a2 succ (x + 0) = succ (x)\n```\nwird `rw add_zero,` das Ziel um\u00e4ndern zu `\u22a2 succ x = succ (x)`,\nund damit den Beweis abschlie\u00dfen.\n", "end nat -- hide", "Existenz Divisor und Rest", "-- namespace nat -- hide \n", "import data.nat.basic -- hide\n", "import tactic\n", "import game.Division_mit_Rest.level_1 --hide\n", "namespace nat -- hide \n", "Text Text Text\n", "Hint teeeext.\n", "Hint Title?", "More teeeeext (8)\n", "F\u00fcr nat\u00fcrliche Zahlen m,n mit $m>0$ gilt: Es gibt nat\u00fcrliche Zahlen q, r mit $r < m$ und $n = m*q + r$\n", "## Anleitung\nWenn `h` eine Aussage des Typs `X = Y` ist, dann wird\n`rw h,` alle `X` in der zu beweisenden Aussage durch\n`Y` austauschen.\nUm alle `Y` durch `X` zu ersetzten verwendet man `rw \u2190 h`.\n## Beispiel\nBei folgendem Zustand:\n```\nx : N\n\u22a2 succ (x + 0) = succ (x)\n```\nwird `rw add_zero,` das Ziel um\u00e4ndern zu `\u22a2 succ x = succ (x)`,\nund damit den Beweis abschlie\u00dfen.\n", "end nat -- hide", "Existenz Divisor und Rest", "-- namespace nat -- hide \n", "import data.nat.basic -- hide\n", "import tactic\n", "import game.Division_mit_Rest.level_2 --hide\n", "namespace nat -- hide \n", "Text Text Text\n", "Hint teeeext.\n", "Hint Title?", "More teeeeext (8)\n", "F\u00fcr nat\u00fcrliche Zahlen m,n mit $m>0$ gilt: Es gibt nat\u00fcrliche Zahlen q, r mit $r < m$ und $n = m*q + r$\n", "## Anleitung\nWenn `h` eine Aussage des Typs `X = Y` ist, dann wird\n`rw h,` alle `X` in der zu beweisenden Aussage durch\n`Y` austauschen.\nUm alle `Y` durch `X` zu ersetzten verwendet man `rw \u2190 h`.\n## Beispiel\nBei folgendem Zustand:\n```\nx : N\n\u22a2 succ (x + 0) = succ (x)\n```\nwird `rw add_zero,` das Ziel um\u00e4ndern zu `\u22a2 succ x = succ (x)`,\nund damit den Beweis abschlie\u00dfen.\n", "end nat -- hide"]]}